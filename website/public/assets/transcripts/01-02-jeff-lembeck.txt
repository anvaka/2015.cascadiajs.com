     

 ¶¶¶
      >> I won't be singing today.  I'm just going to start, like, asking you guys questions.  Oh, something I really want to do today.  If you follow me or Twitter on R or you've had a real life conversation with me, I love music, I love hip-hop music, rap music, I'm from the bay, that's part of my blood.  I also want to shitty public schools, so as an adult I learned what a.  A public school in the Bay Area.  So I have a bunch of stickers that I brought with me that say I don't know how we feel about cussing here, so it said the F word and then passwords.  If you can come up with a haiku about CSS, I will give you as many stickers as you want.  I'm going to come up with a few.  They're not going to be exciting.  What do you think, Jeff?
      >> So Jeff is from Seattle.  I don't know originally, are you originally from Seattle?
      >> I'm from a Yakima, which is, like, two and a half hours.  So if we can give him a big round of applause, we're going to get started.
      >> So last summer my wife and I started working our way through our cookbook by the name of the family meal.  It was subtitled home cooking.  So Ferron was the chef, which while open was widely considered to be the best restaurant in the world.  So a book like this sounds a little ambitious to try to attack, but it's topic focus was really intriguing to us.
      Ferron and the rest of his staff sat down and had a e-mail together.  The meals were comfort foods if the are staff's home countries, which actually span most of the continents, they were made from ingredients that were easy to store and regreet.  And most importantly they had to scale.  The recipes in the book go from two people up to 75.
      So bringing everybody together in this manner, it was really important to chef, to making something that served his community and making something that everybody could take part in creating by keeping the recipe simple and precise and making the food accessible is something that rings to me beyond the kitchen.  It's how we react one another.  In our industry it's how we best communicate.  We build things that make other live's simpler without unnecessary complications.
      We build things thank first of what is consuming them, not technical expertise we can show off.
      Dr. Ellen Kay said the user interface design first happened when computer designers finally noticed not that just users had functioning minds but a better understanding of how those minds work.
      So today I want to talk to you about building tools.
      Dr. K was taking more about the gooey in that quote, we use coat Cody and text to interact with our machines, if you switch context you might use the mouse.
      We install depends, we smash files together, we take human readable instructions and make them fit language for a machine.  And we sole of the problems that we're faced, and there are a lot of amazing tools out there in order to do that.
      Here's gulp and grunt and make and rake and pip and home brew and a bunch of little words.
      Each one carries with it the hopes of making your interaction with your machine smoother.  But if you ask around, I'm 100 percent certain you'll find somebody who has a complaint about at least one of them.  The opacity of API, and what it boils down to are human factors.  These preferences for certain types of ergonomics in a field where the next hot thing is coming down the pipeline as we speak.  There's one glaring problem that trumps all of those though.  Building tools is super hard.  So in the fall of 2012, Scott jell popped in and demoed something he'd come up with over the weekend.  It was first what we call union con and then eventually we had to rename it so we named it grunt icon, it allows you to handle your icon solution as part of your build process.  It gives you featured fall backs along the way.  It relies on grunt icon, and it really focused on the perspective for someone who didn't like spending a lot of time in the CLI, and we put it out there and people really ate it up.
      But then the obvious thing happened issues started piling up on GitHub of both the terrible bug and the feature request kind.  Scott, he came in on a Monday.  He's written an exploratory rule over the weekend.  This thing wasn't built for a ton of modification, it was built for stages.  It was on 0.3 at the time, and every time we had a bug, we stuck that code on there like a rubber band on a ever growing rubber band ball.
      We had a choice at this point in the project.  We could decide it was worth it.  Like, it had a lot of promise, and we could set aside time for it and work or we could just throw on the readme if you like the idea, fork it and make a PR for your version, and we'll do that, and spoiler alert we did the first thing because I wouldn't have anything to talk about if we did the second.
      So say you're in the situation we were in the grunt icon, you're a coworker and you came up with something over the weekend, and it was super awesome and you were excited by the potential for the project.  And right now your script works, but you're starting to notice these little holes.  There's no tests, it was tied to a build tool, it's super monolithic, yeah, so you release it to the public, you put it up MPM and GitHub and tweet about it and whatever we call releasing things to the public, and some people found it interesting and started using it and now issues started coming in.
      So the first thing you're going to need if you're ever going to want to build a project that you and your community can trust is tests.  We need to refactor this thing and we need to make sure that it still continues to work while we do that.  So my advice here is write an integration test.  You already have something that works, so you've got an input and output, so write a test that matches just that.  And that's what works right now.
      So once you've got that, you can start writing this thing and know you've broken anything that works right now.
      When we write code, we write it for humans to read and interact with.  It's an interaction and like any good interaction, it works best if you're amazingly clear of what your expectations are from the person you're interacting with and what they should expect from you.
      Be conservative in what you do, be liberal in what you accept from others.  John was talking about TCP at the time.  But on a broad other scope.  If we want to write something particularly robust, we need to consider what we're accepting as an argument and if it's far too specific.  If we can make what the user wants to work work, we should.  Humans will want to use the thing we built in use cases that we haven't thought of yet, and it's up to us to be immensely understanding and help them when we can.
      On the other end, we need to be clear and consistent with our output.  Keep the return type the same, keep the format the same, keep your output heavily document, and make sure people know that they can process it.  And there are caveats to your tool, we're at a conference, that will get you, we type a certain thing, and let's make the rule this way.
      Be conservative in what you believe of, be liberal in what you accept from others, unless what you're doing is totally absurd, then throw in a error because nothing is worse than failing silently.  Okay.  Maybe there's a few things that are most than that, but mostly those are wasps.
      So since we're talking about command line base tools here.  What are some examples you might want to think about?  How many arguments are expected inspect the order of said arguments.  What should your defaults be for options?  Do you take input from standard N?  What side effects might the user incur?
      What build tool?  On the last one from personal experience for this project, don't ever do that.  For the rest of these luckily enough, there are documented and story patterns and tools and that's awesome because you can pick one of these and follow its general tools and you're a good part of the way there.  It's nice.  So let's talk about some of my favorite patterns.  Ones that I commonly use, ones that I come across regularly.  The filter pattern.  It's when you take standard N and output and standard out.  It's commonly known as the Linux way, and stream API.  The most commonplace I see this on my day to day tools like grep, but I also see it in the gulp file.
      So that's the filter pattern at work.  It takes in data, it pipes in to a transformer, and it pipes it to where something is going to write to a file.  In this case it's taking our style files and transforming them to CSS and then outputs them.  Since I mentioned grunt icon, let's think of how we can build that into the project.  The first module of part of grunt icon is a module called director colorify, it takes an input directory, reads through the files that need to have their color changed, and then changes the color of the files and then writes the files to a new directory.
      So at a more granular level, it loops through the directory, reads like that contents of each file, process the file content, and then writes to file in a new directory.  So this is perfect for a filter pattern.
      So the command line, excuse the bash, this might look like this.
      So LS list files on your directory.  And as those are listed, they're piped through a wild loop, which reads them.  It will output the current file's contents, and then it will transform, and then that outputs to a new file.  And I should change that so it works that way soon.
      Next up is the Cantra pattern.  You run a command, you don't give it standard N, but something along the way.  You'll see this all the time, but it's super side effect driven, so it's best to communicate through your user with your command file so that all they'll see is a exit status or error to let them know it didn't happen.  You'll see this quite a bit are M, remove a file or touch, which is, like, creates a file.  That's empty.  Or, you know, clear, which just clears your screen.
      Using the directory colorify, for example, this is kind of easy to imagine.  We could have directory colorify take a couple of parameters that input directory, output directory, put an option on there for color.  Unless there's an error, you're going to get no feedback.  All the files are created, so I guess you're done?  All right.
      The source pattern.  No standard N, but you output to standard out.  And frequently reports the states of said system.  And the example of this is LS.  It lists the files that are in your current directory.  For the sake of consistency, here's how a shoe horn this partner to the directory colorify model, and to be honest I wouldn't do this, and that's good because it's useful.  But let's look at the example anyway.
      So directory colorify would do the reading of a directory and then it would perform all of the color transformations for you, and then it would output the files that have been transformed, probably with new lines separating them.  So you can afterward -- so that's just the hop line -- so you can afterward read line by line put the outline and then put each line into its own file.  And write to file.  And the last example I'll give you is the compiler pattern.  So the compiler pattern might seem except, it reads files, it performs transformations, and it writes files.
      And it doesn't do it standard to standard, it actually reads files itself.  The same comes from compilers, but you'll see this enough in grunt tests.  The directory colorify example of this, it's interesting enough.  Read through our input directory, we rock that loop again on that list of files.  Colorify will handle the file reading, the transformation, and the file writing.  Which is kind of a separation concern problem, but that's that.
      This is kind of how it works right now.  So when it's time -- when it comes time to address how your tool is interacted with, you should give a thought to these kinds of patterns.  When used established patterns to create your software, it's likely to be a familiar feeling, and that makes your intentions more transparent, which gives user experience that prioritizes ease of use.
      So ease of use doesn't just cover patterns and adhering the best you can to law.  Keeping the service area small means that your users have less cognitive overhead when adding your tool to their arsenal.  The idea goes back to something that a bunch of smart folks that is still useful today.  Write.  Programs that do one thing and work well.  Write programs that take together.
      So say you've got grunt icon on your hands again.  It started this monolithic tool that took a couple of arguments, it was a directory to read and output to write to.  So once it had those things, it read the input directory, it performed color changes on all DSVGs that were requested of it, it confederate to PNGs, it created a separate CSS file for the SVGs and the PNGs, and then it created a lowered snipit, and then it created a preview HTML file so you could see what your results were.  And it was written in, like, two or three functions.
      So maintenance on this was hard?  So rewrote it.  Now, grunt icon is composed of a few different small libraries.  Honestly the separation alone closed several issues as folks kept asking for small pieces the functionality anyway.  It also made it dreamy in comparison.  And we used versioning and that made updates dreamy for us, and tests were way easier tore write like a bunch of little functions that do one thing.  So do one thing.  Do it well.  This makes your code far more reusable, it makes it useful, small, simple, you can make it reusable, you can follow established patterns, make it accepting of all sorts of potential input and incredible explicit in its output.
      So you can make the user experience something you take pride in.  Because honestly when people talk about tools, that's what they end up talking about.
      And now that you've done all of that, it's time to talk about the last part of building something like this.  Look around you.  These people, they are here, they're your community.  And when you start building tools that get a little bit of traction, you're going to need them because try to go at this alone, it will wear you down.  So when dealing with the community, be quick as you can to answer tickets.  You don't have to fix issues right away.  Sometimes you don't have to fix them at all because people get when a feature is out of scope.  But letting them know that they're heard, that's a pretty important place to start.
      Set up contribution guidelines on a code of conduct.  You need a place to point when someone isn't meeting the expectations of your project.  Because remember this whole thing is about people.  Like, when you're building this stuff, it's about people and interacting with people and building things for people.  So guidelines help set the bar for how we converse with one another.
      No bike shedding allowed.  Make code style decisions early.  Add here to them.  Make it linting and enforcement of those code styles part of your build because if these things come in a poll requests, like, on anybody should ever have to tilt at that windmill.  Don't be afraid to hand over the keys to your project.  Like, if somebody is making contributions to them, give them a commit.  You would be really surprised at how well humans handle trust.  Use tools to build your tools.  Starting everything from scratch is the path to tiers and madness.  So in the spirt of people and goodness that we're talking about here, let me give a shout out to one of my favorite tools for building CLI stuff, so if you want to get started on it, it's a really good place.  I use Yargs, and the people who make that clearly know what they're doing.
      So if you're a person who is not building these but instead is using these tools, remember to be kind.  I'm 100 percent certain that I'm not the only person in this room that's received a nasty e-mail or a GitHub comment or, like, getting a thirsty random all up in my Twitter mentions.  We're all people here, and we're professional, so that behavior is unacceptable and will not be tolerated.
      What it comes down to at every part of the process is finding all of the empathy, and finding a way for your users to contact in a machine in order to solve a problem that you've run into.  That's difficult from a multitude of reasons.  But really understanding the user and their problem and how the tool can solve it, that's the most important reason.
      So let's bring it back to the beginning.  You've come up with your little one off script, and you're pretty on proud of it because it's, like, useful and you're looking at sharing this thing, and I'm super excited for you because that salary really good feeling.  But now be aware that you're a little bit blind because of the extent of your domain knowledge.  Someone really smart said we don't know who discovered water, but we're pretty sure it's not a fish.  A.
      That thing if you put on the in the world, if it has users P.  It's not just yours anymore.  Once you find the way where can and time to revisit and really put the interface together.  So who is this for?  What are they looking to do?  How are you making their lives smaller?  These thoughts should be running through your mind while you building the tools and the answers should be ready to change as soon as you get more knowledge about how these people are.  Because we build so much open source software.  There are over 160,000 packages on MPM right now.  So if you really want to deficient your product from others that do something similar, you can start by empathizing with your users.  And it's been a cornerstone for our industry for decades, so let's go get out there and build some stuff.  Useful, useless, fun, boring, none of that stuff matters.  What matters is you think about people while you make these things.  Thanks.
      [clapping] 
