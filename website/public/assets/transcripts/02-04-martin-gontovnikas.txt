      Hello, CascadiaFest! The livestream captions can be followed on your handheld devices at 2015.cascadiajs.com/captions.
      [Captions provided by @chaselfrazier @whitecoatcapxg. Thanks to our sponsor @mobify!]
      >> Hey, everyone.  Did we enjoy the coffee?  Sorry I was enjoying too much coffee.  While we were waiting for our next speaker to get on stage, I'm going to take that as before mentioned selfie.  So if everyone is okay with that, I'm not sure if I'll even be able to say you.  Yeah, this is great.  One, two -- yay.  Thank you so much.
      So I would like to introduce our next speaker.  I have been diligently practicing his name for you.  I would like to introduce Martin Gontovnikas.  A developer advocate for a company called in off zero, he's from Argentina.  Please welcome him to the stage.
      [clapping]
      "Death to Cookies, Long Live JSON Web Tokens."
      By: Martin Gontovnikas.
      >> So as she was saying, my name is Martin Gontovnikas, and I'm going to talk about JSON with tokens and how we can do our indication with them instead of cookies.  So -- oh, wow.
      So the title is like -- I don't know I just put this kind of title so that the talks is, like, death to cookies.  It sounds awesome.
      So we're in the tech world, so my Twitter handle, if you want to follow me and increase my ego, I would greatly appreciate it.  And I'm basically a software developer, and I work at off zero, that's another thing that's really hard to pronounce for me.  Off zero is basically a Sass that has authentication, so if you want authentication made easy for you, you can use it.  If you're interested, you can talk to me afterwards.
      But I used to be there mostly coding JavaScript all day long.  So this was me.  I love this cave.  But right now I work as a developer advocate.  People ask me, like, what does a developer advocate do?  And this is me when I was 17 in so instead of singing, and I speak about that in different place nor the to be able to speak of course code.
      So let's actually start with the talk.  But before starting with the talk -- well, I have one question.  It's unrelated with anything.  Hands up who is a morning person?  Okay.  It's not that many.  I'm glad because I'm not a morning person and all conferences make me wake up at 7:30 a.m.  So basically this is me.  Every morning.  And I want you guys to be listening to what I say.  So basically what I thought was to put flashy lights to wake you up.  So let's look at them for five seconds.  Okay.  And the other thing I was thinking about doing T-shirt time.  I always wanted to throw T-shirts and everybody loves T-shirts.  And if you use them, you would be walking promotion for us.  So why not; right?  It's free for everyone.  So I'm going to throw one.
      I've been practicing in the room.  It's like from across the bed.  It's like -- so a little bit more flashy lights.  And I think we're awake.  So now we can start.  So how does the Web work right now?  Let's imagine that I'm going to -- I want the Apple watch, I bought it on Apple.com.  So how would it work for me to be able to buy the Apple watch?  The first thing we have a browser and a server.  And every time I want to buy something, I basically have to log in.  So I sit down, I enter my user name and password, and I click on log in.  That will send a post request to Apple.com server sending the user name and the password, the receiver will receive them, it will go to the and if severing okay, it will create an object in the session.  What is the session?  The session is some in-memory storage where it will have all of the authors that are authenticated at a given point in time.
      So after they check that I exist, they will create this user object in memory in here, and it will have an ID, and they will send that ID to the browser.  How do they send that ID to the browser?  They basically use cookies.  Cookies is something that is built in on the browser.  So the browser will see that the response got this cookie.  It will see that it's for Apple.com, and it will basically save it in the browser.
      So now I want to buy something.  So I click on buy.  When I click on buy, my browser is diligent because it says Apple.com/buy.  So let's send it.  Maybe it's useful.  I don't know.  So it just sends it back to the server, and the user exists, it will go to the database, and, like, take my money because I'm buying the Apple watch.  So that's all it will do.  So it's basically getting as I was saying the cookie, it was getting the user ID from there, and then getting the object and just taking my money and sending the response to a server.  And this is how most of the Web works right now.  And that actually used to work really well.  But there's a problem now because if we're here, we're in the browser right here, it's for because we're starting to do a lot of stuff in our browser and not everything in the server.  And that doesn't work very well with that.
      And there are a couple of reasons for that.  First one is cookies don't play well with code.  So you have Apple.com and the server.com, and you want the browser to be able to call them from Apple.com to server.com, you need to use course.  And if you're using cookies, you probably saw the same stuck over, because the first thing we do is Google, and the problem is that of course it needs to send the options request before any request.  And if you're using cookies, it's even harder because you need to say, like, with credentials I need you to respond something special in the option.  So it's really hard to make it work.
      Another thing that cookies actually require state full servers.  So what does it mean state for or stateless?  Something, like, two words, something at least stateless is that given an X request, I always get the same Y response.  Because there's, like, no side effects.  When I'm using cookies, there's a side effect because I have this in memory storage that is called a session, and that session is state, and I'm checking versus that to see if the user is authenticated.
      So in case I'm getting bigger and bigger, and I have three servers now.  So I log in with server one, and then I get the response and I click on buy, and that goes to server number three.  The server number three will say, hey, this user is not logged in.  And that's because the session is only on server number one.  And that doesn't work because this depends on state.  And HTTP is actually a stateless protocol.  Because given the axis, it only gives Y, it doesn't know about past requests, it only currents one.
      So making this with W cookies on the session is -- how it works, how HTTP works.  What we do with the three sessions is we have the session that's shared between the servers or something that's called sticky session, which is if I logged against server number one, all my requests will go with server number one.
      And as I was saying, API with his be should be state the.  If you can to Facebook, Twitter, whatever, they're all stateless and none of them use cookies.  And it's easier to the bug and easier to maintain because you fight only depend on request in this X pop to test something and know what's going on, it's really easy to test against that.  If I depend on another state, another thing, another round, function, not only on the request on the input that I have, that means it's going to be much more work for me.  And Google Facebook and Twitter, probably anybody who used API doesn't want to lose their money and spend money on debugging, so that's why you should make your API's stateless.  And most frameworks by default use this in memory session.
      And the other thing, which is the hardest is that cookies don't flow.  Every time we have more and more servers that we depend upon.  So it's not only my single calling a server, it's that server then calls another server and then another server calls another server.  And what I want is if I'm doing an authenticated request, I want that identity to flow between all of those servers and all of those requests.  And if I want to do that, cookies work well between browser and server because it's built in the browser how cookies work.  But when I want to do a cookies to cookies call, servers don't work out very well.  Because I need an API, and most of them don't use cookies very well.
      So.  Cookies are really hard to make them flow throughout all of my different servers.  Is to what I want to proposal to you is a better approach, which is token based authentication so let me show you what a token is.  Basically here on the left we have the token, and you might say that's like any token.  But in are reality it's not the.  Because what you see on the right is exactly the same on the left.
      The most important part of the token is this blue part, and it's the payload.  And the payload is whatever information you want.  So you can put, like, user ID, user name, first name, last name with or anything like that.  So in here if I, like, change this, like, Martin, you will see what I type the token changes.  And that's because you see on blue is actually a base 64URL encoded of the under write.
      And this section of token is actually a spec from the IETF that went final like four or five months ago, and besides this payload, we have this header.  And this header has some important things and the token and the algorithm in this case is H mark 256.  This algorithm that we specify here is what will make our token secure.  We do base 64 encoded of the pay load, and then through all of this.  We run this algorithm to get a Shah based on a secret.  So now I've got this signature, which is based on the secret, which is only known by my server and the payload we have.  So now let's copy and paste this in this other window that I have.
      And you can see that in here it says invalid signature because what do it sing trying to validate this token with this secret it's doing here.  And it's not validating it because this sitting there was not created with that token.  So in order to validate it, I need to write sure.  And now it's signature verified because it's doing the signature with this payload, and it's checking the part that it got from the token is the same one as the red part, the signature.
      And so based on this, how does the Web work now?  How can we make it work now?  Let's say again I'm buying an Apple watch.  So, again, sitting, enter a user name, password, click on log in, and we'll send the post to the server.  But now first the server will see if the passwords match, and now it doesn't have to save that user in memory storage because it can actually put the user information of who is logged in inside the token.  So it will basically create a token with a secret that only this server knows and in there it will put user ID, first name, last name, et cetera, and then just return that as part of the response to the browser.
      Now, the browser needs to save it somewhere, for example, in storage, and then the next time, the next time it will do a request, we need to send the header.  And we will say better and we will send the token that we got.  So it will send the header, better, token.
      And now the server doesn't need to actually check any in memory state, in memory storage, it just goes to two things.  First it will check if this token was created by this server.  For that it will check that the signature was created with a is secret that only this server knows.  If that works, it will get the user ID first name, last name, from the payload, from the content of this token and once it has it, it will just look and take my money.  But the important thing is that this only depends on this request because the request, this X that I'm getting as I was saying before.  Has all that I need to identify the user.  It has the tokens, which tells me the user is authenticated and inside that I have the user information.  So now I don't need any storage, I don't need any database to save the environment of all the logged in users right now.  So that means now my API is stateless and then I've got just a return a response.  And it will work.
      So the first time I saw this I was, like, yeah, sounds good.  Sounds cool.  But how does it work?  So first T-shirt time again.  Let's try to the other side now.
      I'm so bad at this.  I have a few others.  So if you are, like, further than third row because that's all I get, you can come later.
      So I will basically stop talking right now and what we will do is we will see it in action.  We will live code.  And what I mean to editor is because there's wording that means -- I am, like, really typo friendly.  I am really good with typos, so things will break and we'll have something like this or this.
      So let's actually do them.  So let's cue the presentation and let's actually start this.  And let's see what we have right now.
      So this is the sample I have.  As you can see I should have spent yesterday doing it.
      So this is what we have.  This is a home, and it has two variable, which if I don't start a server, it won't work.  And basically every -- the first one calls an API that doesn't require authentication and the second one that does require authentication.  So what do they return?  Most API returns any random 50 Chuck Norris prices because everyone loves Chuck Norris.  So every time I click on it, I get 50.  But since I'm on here, I get 100.
      So if I click on closer API, it's saying no authorization header was found because I'm not sending any token.  So we want more Chuck Norris, and we need to implement these and let me show you the application.  This is the application that I have, it's the index HTML and in this case I'm not using any framework at all, I'm just using repo for template, but other than that it's JS, and let's actually see first see the home.  Sorry let's see the index.
      So when it uploads, it will require this boot, and this boot all it will do is require other things.  So now it requires the home.  And the home has these whenever you go to the page which is fruit, this one, it will just render this home view.  And this is the JS with all the methods, this quality API is the one we're using, and this is the HTML.  So what we need to implement now is the log in.  So if we go to the sign in folder, you can see the HTML is already created, and I had to make it before.  And this my very complicated CSS.  Just with 40 percent.  I'm a genius.  I know.  So now let's implement this.  The first thing we want to do is implement the route.  So we'll do something that most developers love, which is copy paste.  So let's come here and copy paste.  And then let's say this is the signing view, we will require assigning, and then in this case the URL would be sign in, and that's it.  That was easy; right?
      Now let's go to the more complicated part, which is the view.  Again, copy, paste.  We're good at this.  So -- oh, I actually messed it up.  See I already messed it up.  This has to be in the index, not JS.  Now let's copy again.  So we come here, we copy, we paste.  Now what we're having is the HTML would be signing the HTML and then the website will be called sign in.  So now we just have to implement it.  So let's see what we have so far.  In the HTML, we basically have a user name, one for password.  So what we want is to -- when the user clicks on submit, we want to log him in.  So let's say that whenever this is clicked, we will actually do -- oh.  It changed my key word.  Sorry.  I don't know why it happened.  But I have a Latin-American keyboard.  So if it changes for me, it doesn't work.  Now it works.
      So we will did stop log in.  And then whenever the user stereos log in, I want to get the user name and the password.  So let's say this will be the user name and this will be the password.  I'm using it to be able to get these values basically.  So now all I need tore implement is this log in method.  So we can come here and say sign in dot prototype do the log in, and this will be a function.  See I'm very typo friendly, let's first prevent the fault, and then all we're going to do now is call our API.  So for that we'll the URL will be HTTP, look at hosts, sessions create.  In this case we'll do a post.  We will send some JSON.  And the data we will send is basically the user name and the password.  So the user name will be this dot this dot value.  And the password will be this dot ref dot password dot value.  And once we have this, then we just need to process both the success.  And this is the success case and the error case.  If there's an error, you just do error dot response text.  And if it works in the response, I'm getting the JSON Web token, it's called ID token, and we're going to save that and look at storage.  So let's do storage dot JWT response dot ID token.
      And now if everything worked correctly, we're going to go to the home.  And if she had actually it.  That's all he need.  Now we just need to add this to the biological boot.  So now besides the home, we will also have now the sign in page.
      So let's actually try it out.  So, no, console, that's the first good sign.  Let's go to sign in, and we have the log in.  So let's try something else, like, user name ASTF, the user name and password didn't match.  That's good.  That means it's calling the server.  First good thing.
      I created the user name that already exists, and now I'm creative.  And if I click enter, I mean home.  But did it work?  Didn't it work?  I don't know.  Let's actually go here to resources, and let's check storage.  And here we actually have the JSON Web token.  So I paste it here.  You will see that this one has the user name, and these two fields are issued at when was this token created and expire when this will expire.  I'm going to go over time.  Sorry for the next one.  And no, you that we have this, let's actually display it.  So if we come here to the home, we can get the JSON Web token.  So let's take a, say, that it will be local storage dot get item, JWT, and let's actually display it in the view, so let's say.  Now, if I replace this, the token is shown.  And since it's encoded, I can just show it.  So I have imported this code, it's from GitHub, and it lets you decode the JSON Web token.  So let's say it encoded, if there is a JSON Web token, and it will just do a charity code of this, and that's it.  So now let's receive this and show it in the view.  So not view now we're showing this JSON Web token, and the coated JWT in JSON format.  Refresh.  Now we're showing the same adds JSON Web token.  So hands up with things if I click on API will work.  Okay.  It won't work.  Let's click on it.  Why is it not working?  Because I need to send the JSON token.  So let's just do that about and in here let's add in headers, and let's say that these -- hart word to write.  Authorization would be better.  Plus this dot GIT.  We're getting the token so from the view we can do this dot GIT.  So now let's refresh and click on call secure API, and boom we have the other 50 Chuck Norris phrases.
      And a state of being logged in doesn't exist.  What does it mean to be logged in?  It means having a local storage, that's all it happen so if we want to implement log out, all we have to do is complete this JSON Web token.  That's it because after all of on you secure content is behind on AI.  And that API can only be called with a JSON Web token.  So if it's not there, we won't be able to call it.  But you have to keep in mind that all authenticated pages will still exist.  The HTML and JavaScript will still exist.
      So if we come here to the log out button, we can say on click, it will actually do this dot log out.  So let's come here, and let's say that home page dot prototype, another hard word, log out equals function, we're going to prevent default.  And then all we have to do is just remove this value from local storage.  So remove item, JWT and go again to the sign in page.  And that's it.  It's write out.  Click on log out.  Boom we're in log in.  However, when I go back to the root page, I can still see it, even though there's no JSON Web token, even though I can't call a secure API, I can still see it.  And there's no sense of being logged in, but we can actually make it easier, even though if most of the source will be able to say the HTML, we can make it so if there's no JSON -- if there's no JSON Web token, we can go into the log in.  So let's actually do that.  We can have secure routes here.  And if this page it's the express based routing for the front-end.  So we can say here that whenever he goes to a page that's not sign in or sign up, we can check if there's a JSON token and if there's not, right into the log in.  So I'm not really good with regular X, so that one I have to copy paste.  This means every page is not sign up or sign in; right?  Really clear.
      So in this case we're going to get the context and all we need to do is get the JSON Web token.  And let's actually add a tricashe, and if there's coated, then we're basically going to send the user to sign in.  So let's say we're going to sign in.  That's it.  Otherwise, you can see the page that you wanted to see.  You can go to whatever you were going.  You can go to whatever is next.  And in the.
      So now let's actually save this and in here, we need to require this file before everything else so that it gets executed before going to any other page.  So let's require secure routes.  Now if I refresh, I'm getting sent to the log in.  I delete.  Enter.  Get sent to the log in.  Now if I log in, I get this here so I can now go to sign in, and I can go back to the root because there is actually JSON Web token.  But this is just to make it easier for the users if they go to a authenticated page to go to a log in.  But still keep always in mind that this page HTML can still be seen by this person.  Only the thing that I want to do is we know that this is a JSON Web token.  So let's say I'm in a user.  And I won't have to pretend that I'm another person.
      So let's say -- now I have this new JSON Web token.  So I go to the website and change what the log in storage.  That's it.  So let's refresh the page.  And if I call secure API, will I be able to say that I'm malicious?  Hands up who think I will?  Good.  If you want.  So now when I click on call secure API, it says invalid signature, and it's not the same as the server.  I don't remember which one is which, but it's not this one.
      So with this we can see that we can tamper this system either.  So let's go back to the talk.
      Oh.  I keyed the wrong server.  So most of the things that we have seen today.  If you want to get the slides or the GitHub project with all the steps of what I have just live coded, or I also put the articles on how to do authentication with JS like this one with react one and two.  You can just go to this URL, and you will be able to say all of that content in there.  I also put my Twitter handle there.  So if you take a picture, you can remember me.  I'm kidding.  So that's basically it for me.  So that's all.  And thank you.
      [clapping] 
