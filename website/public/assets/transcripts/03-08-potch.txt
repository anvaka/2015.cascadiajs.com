      >> Thanks, Rebecca.
      >> This is amazing.
      >> The bear ran away.  I scared it away.  So we're okay.  Rebecca is okay.  Everything's going to be fine.  There, there.
      >> So I do have a question for you, though.  Tell me more about the tacos.
      >> Those tacos are a cultural institution, breakfast tacos especially.  I don't know why this isn't a nationwide thing.  But those tacos always on flour, always always always on flour.  Trashy trailer park is, like, fried chicken, lettuce, pico, cheese and more cheese.
      >> I already ate lunch and now I'm hungry again.
      >> Yeah.  I would be okay with some of those tacos right now.
      >> Great job.  Thank you.
      >> Appreciate it.
      [clapping]
      >> Just one more reminder since I kind of screwed it up earlier.  But if you're taking a shuttle, even if you already RSV (p), just to make sure that you write your name down on the list otherwise you might not have a ride.  And that would be a bummer.  We're pretty close.  So our next speaker, somebody that I call a friend.  Matt Potch, he's here to talk to us about scratching that itch.  We'll see what he means by that.  But command line I'm excited to hear what you have to say.
      >> Hi, everybody.
      "Scratch That Itch - Node on the command line for fun and profit."
      By: Potch.
      >> Yeah.  I'm going to be talking about command line node for fun, not necessarily for profit, but definitely for fun.  Hi.  I'm Potch.  I'm really terrible at picking recognizable head shots.  In retrospect, I probably should have put something up with my face up.
      So, hi, I'm Potch, and I'm a Web developer advocate at Mozilla.  So what I do is I go out and talk about Web technology, and I go out and talk about -- you know, encourage people to take closed platforms and open them up or build weapon apps instead of native apps or turn back in and say, hey, we need to fix that feature in the product.
      I'm actually not talking about any of that today because the talk that got accepted was about command line node, something that I don't do in my day job and I do in my fair time.  And I have a confession.  I'm a little lazy.  Lazy is not the right word.  I hate context switching.  I hate being in the middle of one and things having to go do another thing.  Probably because of some attention deficit thing that is as of yet undiagnosed.  But I hate going from this, which is really where I spend a lot of my day when I'm coding, which is 80 columns of terminal with tests and build and the rest of the screen and editor, and then I have the browser on a second display or second space, and having to stop what I'm doing and go look up that function definition for that function is it needle or haystack?  Is it needle or haystack?  I can't remember.  I love PHP.  I have no problem with that language.  I'm building some stuff in it right now.  This talk is a pure -- comes from a pure place of love.
      But sometimes when you're out going to hunt down that exact piece of documentation you need, you get distracted.  And you find yourself reading about fictional bears.  Wikipedia is the greatest resource -- this is why we fight right here for the Web is so a list of fictional bears will always be preserved.  Or even looking up specific references in Billy Joel's we didn't start the fire.  And all of these distractions really add up you end up wasting a lot of time in your day.  It starts off even if you get your job done, even if you complete the task you meant to do, losing 30 seconds, a minute, two minutes.  If the documentation is not the great, five minutes, ten minutes.  Or if you get distracted, several hours where you come out of a days and wonder why Doris day is on your Wikipedia with seven or tabs open.
      So what you do in this situation.  If it's a piece of information you know you need all the time or certain types of information you need all the time, you could try replacing a part of your brain with a simple shell script.  And when I find myself in times in trouble, words of wisdom, XKDC and -- this is an awesome table.  How long you can work on making a routine task more efficient automating part of yourself before you -- if you're anything like me and just constantly checking small things, you're going to find yourself in this corner of this table.  Maybe five times a day you lose 30 seconds or five times a day you lose a minute.  You could spend that time building a tool for yourself.  Or maybe even just an hour making a little shell script to go out and check something.  You know, the website in a loop to let you know when GitHub is back up online so you don't get too distracted is a great example.
      And when I think of little tiny tools, I think of the command line.  In fact, it's a whole 30, 40 percent of everything I'm looking at when I'm not in the browser.  And there's this notion in command line stuff, especially in schematic Linux, which really distills itself down to this acronym.  Do one thing well.  And what that really means is trying to build a very simple, very straight forward tool that takes something in that's very clear and outputs something that's really, really clear.  And constrain that scope down.  And that same metaphor works so well when you're trying to replace one small part of your brain.  If you can only justifiably invest a couple hours of a week or on a weekend taking advantage of little small you can automate.  Then you want to build something that's small, controlled in scope, and is really kind of always at your fingertips.
      There's another community that has a similar concept -- I'm realizing my slides are not advances with the jokes.  Here we go.  This community right here.  This is the node community.  And this was an awesome visualization from yesterday's talk if you didn't get a chance to see it, you should check it out.  But it's incredible to say that the node community has these millions and millions of packages that can stand in for a small part of your brain.  And it's just like the small things that work together.  And it's no surprise that node is an amazing tool to build things on the command line.  That's pretty obvious.  Node runs in the CLI, and NPM makes it really really easy to build these things.  That's what I'm going to talk to you about.  Find that one small problem that's been nagging you and replace it with a command line tool.  And please don't follow along for this one.
      This is the remove tool.  It does one thing.  It removes things from your computer.  And it takes a couple of arguments -- and then it does its work be and it tells you about it on standard out.  And if there's any issues standard error.  I would like to point out that the eye flag puts it interactive, so you're not going to have a bad time.
      And how do we access -- there's also standard N, and a lot of the tools you're invoking from the line and the examples I came up for this talk don't have standard N, so I'm not going to talk about it too much.  But does node have an equivalent here?  And it does.  The process variable, the process module gives you access to all these extra little nice that things let you hook back into the command line and the environment lets you do these exact things.  In fact, the things are standard out and standard error.  And these are actually really conveniently wrapped console that log and console that error.  So we have right at our fingertips exactly what we needed to the most basic activity.
      But how do we get the arguments from there?  The good news is -- so we have this argument and this list of that things come after the word NPM.  And they're all broken up, split on space into a list of tokens called process dot RV.  And that actually returns just a list of all the things you see.  It doesn't tell you what order they're in.  It doesn't really give them a whole lot of meaning, but it gives you access to everything the user typed before they press enter.  So we have all the power we need and now we're going to go out and build something completely incredible.  It's actually probably a little closer to this.
      [Laughter]
      The goal here is not to build a tool for everyone.  Not to build this incredible, I'm not trying to build the next gulp here.  I'm trying to build a small, simple thing that's really just solving your problem.  It's sort of funny I get up here right after Rebecca says people have solved most of your problems and you should go out there and find them.  And I'm saying when you need to solve a problem for yourself, sometimes you should build something to have the satisfaction of making it wrap around your headspace.  It doesn't mean that everyone else needs to use the same command line tool you need but it means when you're trying to solve that one small task, you can build something that is good enough.  And you should because I think it's a great exercise.
      So doing developer relations, I find myself in a lot of airports, wondering where the hand of fate is going to leave me there for several more hours.  And I find myself constantly rechecking my flight status.  And Google actually does an amazing job with this information.  If you search flight and then your flight code, you're going to get one of these amazing one boxes.  I mean if you were here on Wednesday, you actually heard about micro -- sort of microtransactions and microcopy, and I think the airplane progress bar is a great example of that, it's just a little bit extra information in a way that it doesn't have to be presented that adds a little bit of fun and in a way that I genuinely enjoy.
      And what if we could get all this information on a command line?  And I found myself in a airport wanting the exact thing, so I spent down for about half an hour to get the minimal solution out, and I want to show you the thought process perform.
      So where am I going to get this information?  Well, if you zoom out from the one box, you actually see there are tons of websites that do this exact thing.  So I just grab the top result.  I went straight to flight aware.  And their website is awesome.  It's so much deep, nerdy information about flights.  If you are interested in the average on time performance of that plane, it's a lot of fun.  Sometimes I just punch random flight codes in just to see what's going on, you know, and try to figure out is there a patterns to united's code?  The assistance no.
      But to build a command box over here on the side, we've got our time, our on-time performance, and we have that progress bar.  We have a percentage based piece of information of maybe that flight that's inbound, or you're waiting to pick up someone from the airport and you need to know how far away the flight is.  We have this awesome piece of information that you can borrow all of this.  We're building this for our own personal use I just want to point that out.  So threats crack open the DEV tools and see that table is still alive and well on the Internet.  If it ain't broke, don't fix it.  And it's not.
      So let's take a look at in here.  And this is the Firefox inspector, but use the tools that you like, and actually that this is table based design, ornamented so let's grab that page and take some information out.  Node has a built-in facility for this and really just getting a page, this is more than enough.  But I actually have thought to reach for a module, I wasn't for sure I needed to do something in advance.  If you're familiar with Python request module, it's the same thing, it's just one method, request, it takes all kinds of arguments, and it makes it really, really easy to interface and grab stuff off the Web and redirects and all those nice things.
      So here's actually the boilerplate.  Straight from request documentation.  Give it a URL, and it gives us back a call back.  And he have our error and our result, and we also get the body.  So we can just check if there's not an err and the HTML body of the page.  This is all pretty straight forward stuff.  Do we want to parse the HTML?  We definitely do, and we definitely don't to use regular expressions, there's that great stack overflow thread where everything goes off the rails and it's worth checking.
      And, however, node again has our back and we have cheerio, which is the core of jQUERY.  If I was going to build this today, I may have reached 4JS DOM, which may let me inject into the page, but cheerio is a great solution if you don't need an entire implementation of the DOM.  So here's where that same code snippet looks like with cheerio inside.  We're now going to parse the body as its given to us and put in that dollar variable and now we can start grabbing stuff.  I'm not going to really bore you with the entire implementation of this, but it's a lot of pretty cheesy hacks to get the headers out, and even with classes, we go through and do some wonderful things, like, contents first, text, trim, for just pretty display purposes.
      So we have all of this, and we're going to Britain it on the screen using console dot log.  And now we get this.  Which is a really great little update, but it's missing something.  It's missing that that progress bar.  So let's go back and figure out how we can make this.
      Now, if you're like me, you're probably -- you're probably using a column terminal, but why should we assume that?  Sometimes I'm full screen terminal or sometimes I have a split view.  So how do I figure out how wide to make this?  So node has our back, and we can figure out exactly how wide the terminal is.  We actually just say process standard out, we can ask exactly how wide it is, and it tells us and that's an up-to-date piece of information, and you don't have to worry about the scary terminal stuff necessary to measure this stuff.
      So here we have a final result, and it looks pretty good.  You know, we have all the information we need.  We know when it left.  We know when it's going to get in estimated, and we know how far along it is, and we have a great little airplane, I don't know function that.  I was pretty pleased.
      But it's missing something.  I feel that there's extra information here that we're not getting.  There's the terminal and the gate, but there's this instantaneous flash of color, and before I know this plane is moving forward, my plan is proceeding as expected.  So if you're familiar with consequences because you spent too much time with dass, you know that this is how you make green text.  It's pretty attractive.  It's pretty straight forward.  And if you remember to reset everything, you're going to be all right.
      But if you're not comfortable with that and actually I'm not either.  I had to go relook all this up.  There's chalk.  One of dozen online terminal color modules for node and you can actually just wrap it in a function, and it spits out exactly those exact same consequences but in a really nice, human packages.  So now let's splash some color all over our thing.  We have some blue sky we're flying through.  We've got red, which means the flight is not running on time, even though the text says it's running on time.  That's okay.
      [Laughter]
      I'm actually got an debug that.  So let that be an exercise to the reader.  All these are online.  You'll be fine.  And, yeah, really simple.  It took probably I think an hour, hour and a half for the initial implementation, and I wrapped it up in a little tool called flight status.  And even I made it for me, I open sourced it because I'm a nice guy, and you can play along, and I haven't put something in the readme yet, but Incas someone who struggles with the open source projects, it's totally okay to say, hey, I'm opening so you went this because someone will find it useful.  But I'm not building it for a audience.  This is code that will shorten someone else's work, but I'm not trying to build a tool for everybody, and I'm not going to get offended if you fork this and change it in any way as you want or take it and market it as your own.  That's what open is about.  And there's this ownership of, well, I put the code up first and the whole truth has to be back in my module.  Or if you're contributing to a project, you feel guilty about forking it, and there are tons of situations here where people say why did you not send this change back up to me?  Why are you not promoting my project?  But I like the idea of no maintainership implemented.  And if you're interested in this code, have at it.  And if you want to maintain it for others, please do.  I'm not -- no manor ship intended.  I think that's something that would make a lot of our lives a lot easier because node is full of modules.  And, in fact, if one of you wants to maintain a flight status thing, I will give you that module string.  I promise.  It will be yours because sometimes I fix bugs in this and sometimes I don't.  And I fly united a lot, so I fix the abbreviations for united but not for delta.  So I'm really sorry.  But patches to your own systems are more than welcome.
      So in preparing this talk, I asked myself, Potch, why didn't you just use the API for the site?  And I had to reverse justify why I had done it for the purposes of this talk.  And I decided to go with the answer that scraping is API zero.  The Web is inherently a read, write, remix entity.  And just because one website presents that information, as long as they're comfortable with you viewing it, you know, shouldn't it be okay for you to build a purposes built user agent?  A screen reader that does one thing and goes out and gets that information?  Well, I'm pleased to tell you the answer is absolutely not.  As I was preparing this talk, I learned with the exception of flight XML, you will only access the flight Web within the any programmer, collection agent or robot for the purposes of automated retrieval of content.  So with your flight aware, I'm very sorry, and I'm going to create an account and use your XML format.  I don't think I'm going to do 10,000 requests a month.  So if you're out there, I will cease and both desist.
      The other reason -- the reason that people tend not to scrape other than flaying rent terms of use violation is that there's the perception that scraping is brittle.  What if that website changes?  And API is a contract, a contract that for many websites is constantly broken flagrantly.  And I ask is this.  Really that different than this?  I feel that I'm pretty hosed both way.  Structures of the website change, and the APIs are not supposed to change, and they co.  If there's an API available, use it.  If you have to enter credit card information, well, you know, check their terms for use, and if it's for personal use and you're not going to make money off of it, check your luck.  I'll definitely post a follow-up tweet if I'm presented with any legal copy.
      And another reverse justification for screen scraping is that it's a great way to check the accessibility of a website.  And this is actually true.  A website you can't scrape has no semantic meaning where you're doing first child, first child, last child, it probably really isn't accessible.  None of that information is marked in any way that has any meaning.  And it's almost a great way to do a check, which is can I -- could you right now write 30 line node script that tells you how many Twitter followers you have?  Maybe.  But if you can't, maybe Twitter.com isn't very accessible because house another script supposed to parse through that page and tell you anything -- anything useful?
      Accessibility.  One of those things that we're all starting to get onboard with.  But what is that abbreviation?  A11Y.  We really like to abbreviate things.  We don't like words any longer than five in tech at all.  A11Y.  A, 11 letters, Y.  I love playing with these patterns and thinking about these words and actually this is -- this is a list of all the words that have an A, 11 letters, and Y, and I can tell you how I got this information, I built an abbreviator or as I call it.  A9R.  So let's go into the bits and pieces.  I don't have a ton of time, but how I put this together.  It does two things.  You can give it a thing, and it spits out all of the words that match, or you can give it a random one, and it will give you one word if you need to compose a funny tweet and you just need one random word.
      So the biggest problem that I had with RV is I get random and A11Y.  I hate command tools where this order blows it up.  It drives me mad.  If you've ever done GIT, I think it's GIT add, and you put the P in the wrong spot or A in the wrong spot, it blows up and yells at you.  So you have two different lists, you write your own logic, or you can use a tool.  And I use Hertz arters nom, nom, and you write the schema for your command line arguments, I have a pattern and it's zero position argument and random, and that's the flag means it has no value.  If you don't put that, it's going to tell you what the value of random is.  And you can see what the query is by grabbing pattern, and I can tell if it's random.  So I did do the service of uploading the entire scrabble dictionary to NPM as a module if you need a giant word list.  It's all upper case, so we're going to upper case our word, and then we're going to see how long our query is.  We're going to get the first letter, the last letter, and then parse that number out of the middle.
      We're going to construct a regular ex.  We're going to filter our entire word list, and we're going to get a list of everything that maps.  If it's random, we get a random index.  If it's not, we print the entire list to standard out.
      I found myself constantly accidentally typing words, and it crashed and there's nothing worse than using a command line tool and getting stacked trades.  So I did a little bit of validation and I found the letter, digits, letter, and print out on the console error and exit.  And this is also available.  The one last missing piece for you having a true command line tool is this bin line.  And NPM will see that and link it and put it on your path.  And you can just type A9R in your command line, and it will run your script.  When you're developing this, there's NPM link, which means when you're in your project, you install the link and if you've ever wanted to do any global module testing or testing in general, NPM link is a great way of not having to do the link of NPM publish, NPM patch.  So what happens is it's going to simlink our script and wire up as A9R.
      So I definitely sped through that last part.  But you can see there's a really, really -- I love building little dumb things.  There's also a great unicode command line tool where it gives you a random character and you can search for taco, and see if it made into unicode 8 yet.  It did.  And I think solving your own problems and not worrying about what problems are already solved for you is a really great way to build your skills as a developer.  It doesn't mean to take what you've learned and make it into the next great framework.  It just means you've got to figure out a little contained piece on your own and make something -- and just close that loop.  Get that dopamine.  It takes so long to ship things.  Make something tine tiny.  Finish it.  Finish it to whatever standard of quality you care about.  It's only for you.  Thanks.
      [clapping] 
