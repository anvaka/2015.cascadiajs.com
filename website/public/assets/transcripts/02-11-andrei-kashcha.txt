      >> Awesome.  Thank you, Tessa.
      >> So I was just wondering if you had maybe an example of a Web component that you've created either for work or on a side project just as an example of something you've made yourself.
      >> Whenever I've worked on, like, react or an ember project, you'll always have to end up making tabs component, like the one I was showing there, so I feel that I've built that in some frameworks.
      >> And it comes in useful often?
      >> Yes.
      >> Well, thank you so much.  Let's thank Tessa for the Web components.  Thank you.
      >> Good to go?  All right.
      >> Okay.  Next we have.  Andrei Kashcha.  He's the author of one of the fastest graph drawing JavaScripts out there.  He's joining us today from Seattle.  Let's give him I good welcome.
      "A story of package managers, graphs, and one million vertices."
      By: Andrei Kashcha.
      >> Thank you.  Hello, friends.  Can you see this text well?  I don't know.  Something has happened.  And I cannot see anything.
      Better?  Is it good?  Cool.  Thank you.  It still looks somewhat strange.  I don't know how big the for not looks.  Not normal.  And I swear I had the feeling that I had the feeling like the letters were chasing my mouse cursor.  Weight no.  No.  That's not normal.  Can you please stop chasing my for not.  No, for not, I need you to show slides and text and please.  Stop.  Oh.  Okay.  Thank you, for not.
      My friends, I want to invite you today for a journey.  A journey from a single request animation frame to visualization of huge crafts.  And along the way, we will stop to visit visualization of popular package managers.
      How every visualization.  Every journey starts with a single step, every visualization starts with a requesting animation frame.
      It's just a browser API.  It takes one function, a call back.  The browser will call your call back before next event.  Normally you would use this API like so.  You will ask the browser to call your call back.  And then inside the call back, you will keep asking the browsers to call you over and over again.  And this will form infinite loop.
      Inside this rendering loop, you will update your seen, you will get the particles to do something here.  But browser will try to get you to do 60 times per second or 60 times perfect 1,000 milliseconds.  So which means all you have inside this dysfunction 16 milliseconds.  It needs to be super fast.  And the fastest rendering North Dakota Web today is called WebGL.  WebGL is very, very powerful, very fast technology.  But it also requires a lot of code to get started with.
      I'm going to be using 3GS, which is built on top of WebGL, it's very powerful too in its JavaScript library.  But it also requires some coding.  Less than WebGL, but some code.  So for the sake of simplicity, I'm going to hide 3GS behind an interface so we can focus on the journey.  With that in mind, let me show you the first example.
      In this example we have request animation frame.  Request animation frame we call our call back, and then we keep calling ourself.  And inside the call back, we render the scene.  In this example we're rendering particles.  Particle on dots on the screen.  So here we set X and Y to the random position.  And if you open this in the browser, the browser calls our API60 times per second and every time it calls us, we update the particle.  So this is normal.
      Now, let's refactor this code a little bit.  Let's extract this particle initialization into the JavaScript object.  So now the particle as an object, which has X and Y coordinates.  And since nobody is updating this, it has stopped, nobody is moving X and Y, the browser calls 60 times per second.  Now, let's ask the particles to chase our mouse cursor.
      So now we are learning to the regular DOM event mouse move.  And every time you move mouse, we set a new target.  X and Y.  This is ideal target for the particle.  So each particle will try to fall toward that coordinate.  Now, if you -- you see the mouse chasing the cursor.  And you see moving particles here inside the requesting frame.
      Now Western how to render particles.  This is good.  And to recap a little bit.  The request the information frame is just the browser.  API its been called 60 times per second, and it needs to be very, very fast.
      So now let's talk about graphs.  Graphs are just data structures.  They have nodes, and edges.  Connections between nodes; right?  These white lines.  But how do you render graphs on the screen?  We know how to render particles if you render these nodes at random positions, you end up with this.  This is hard to understand.  And there's no structure visible here.  So how do we go from this mess into this nice little structure?  How do you even explain that the browser what is nice looking?
      Turns out that there are several methods in which we can address.  First we want to reduce the amount of intersections.  The smaller amount of intersections we have, the less cluttered it's going to be.
      And then the connection between the two nodes have the same strength, there's no reason why they should have different plan.  They should be the same.  And finally if the algorithm could detect the symmetry on the graph.  So this is the same graph, yet you see the structure immediately.  So how do we solve all these three problems together?
      Before we go to the solution, I wanted to relax a little bit and look at this peaceful nature.  And it also turns out that nature has the answer to our problem.  If we pretend for a second that every node of the graph is a charged particle, then according to the -- they will repel each other.  And then if you pretend that every connection between the particle is a spring, then according to the hook, they will be held together.
      Now, these are two competing forces.  On one hand it tries to pull them apart, and on the other hand the contracting force doesn't fly far away.  So it's a battle of the two forces.  This battle of the forces is encoded in the module.  And this NPM module takes one argument.  A graph.  Now, if you want to perform this simulation, it's the step.
      And if somebody wants to get the position of the node, they can say give me the position for this node ID.  For this node; right?  Or if you want to combine this algorithm with request in animation frame, it can be like so pop.  Now we will perform simulation inside the animation frame.  And we will see the visualization.  Let me show you.
      Now, you see the forces trying to pull the particles away, apart, and then they hold them together.  They do not let them fly far away.  And you see that the nature solved our problems.  It detected all the symmetries.  It tries to keep the land from doing the same and reduces the amount of intersections.
      But let me show you something very, very important.  Request animation frame still has under 60 milliseconds.  We just added more work and still we have 60 milliseconds.  If we go beyond that point, we will be very, very slow.
      So how do you feed within the 16 milliseconds?  Because the bigger the graph you get, the slower it's going to become.  Somebody suggested use a speed up separator.  This is going to work for Java, C++, and just this forward slash.
      I tried to use it and, again, this is not good.  It's hard to understand.  So speed operator is not really an answer.
      But honestly.  It took me almost two years to find this obvious solution.  How to help our algorithm to escape the 60 millisecond window.  And the solution is very, very simple.  It's not magical at all.  So we just put the computation onto the server.  So now the server can do exactly the same with what we saw before.  The server will get this module and then perform 200 maybe 500 iterations of this battle and then compute the forces for each of the particle.  And finally it will save the results to the disk for each node it will save X, Y, Z, coordinates to the disk.
      Now, the browser can download this file just once, and use this array of X, Y, Z, coordinates.  With this approach, you can render really, really large graphs.
      And our first large graph today is bar.  None of these graphs are shown before in public, and this was created especially for you guys.  So bar has more than 30,000 packages.  And this is how it looks like.  Every Y do the here is a package.  It can fly away here and see structure within the bar.  The size of each node here means the number of dependences.  So the bigger the sides, the more packages.  On sealed you see the bar that are two very popular packages.  What are they?  This is J QUERY with 4,000 dependences.  Can anybody guess what's the other one here?
      Well, all right.  Let's see what this is.  This is angler.  Also you can see that if you fly far away from the main cluster here, there's a star field.  All these packages were pulled away from these forces because they have no dependences, on anybody holds them in the main cluster.  So they just moved out; right?
      But also you can see that the structure, it has this little mushroom over here, so all of them have one dependence.  This dependency is usually very popular.  So in this example it's angler.  It holds this cloud of packages, and the -- the contracting force, it doesn't let them fly far away.  It just holds them there.  Similar to the J QUERY.  It has its own cloud here.  But you noticed that there's this large, large mushroom here, that has no large dot in sight.  So something else is holding them there.  And what is this?  This was huge surprise to me when I checked it out.
      So you see that on anybody -- there's no dependency for this package.  Yet somebody is using all these packages.  So there is a package in the community which has dependencies on all these little dots.  And let me show you.  The package is called everything.
      [Laughter]
      >> Everything has 15,000 packages depends on 15,000 packages.  And the package was created a year ago and wasn't updated since then.  So the bar grew and grew, and it grew, and you see the progress of bar here on this graph.  What's also fascinating about the everything, the bar maybe in general, the ecosystem, the everything depends on this little guy.
      [Laughter]
      A pile of poo.  Speaking of singular responsibility principle, I wonder what's the responsibility of this package.  Unfortunately, I couldn't find this package in the register anymore, but everything still depends on it.  It just gained the dependency of everything.
      So this is bar.  But you probably noticed that something was missing on this graph.  Graph has edges.  We only showed dots.  We didn't show the edges.  Where are the edges?  And why we didn't show them.  So let me show you why.
      This is how it would look like if you would render all the edges.  It's beautiful.  It has lots of edges inside, but it's hard to see the structure there, and also this is one of the reasons that people criticize.  They say that most graphs have this hair ball there, and it's very hard to understand the structure behind this hair ball.
      So this is not very special to bar.  Let me show you how it looks like on the PHP composures graph.  PHP composures has more than 60,000 dependencies, and now we're going to see for the first time in the graph.  So this is PHP graph.  It is beautiful.  But it's useless.  You cannot see the structure within the -- within this graph.
      So what should we do?  We can hide the links and now see the mushrooms as well in the bar and see the most popular packages within the PHP world.  But once we hide the links, we will also lose something.  We will lose this little fellow here, it gets pushed away from the main cluster.  They're just beautiful.  They have all sorts of different structures there.  And I really want to see them.
      So I was looking at this graph two weeks ago.  Very, very sad.  How something beautiful like this could be so useless.
      [Laughter]
      So I hopped into my spaceship and flew outside of this galaxy to the edge of the universe, and I was flying here looking at these little fellows, exploring them, and then suddenly.  Boom the idea came into my mind.  That's the sound of ideas in my mind.
      What if instead of rendering every single possible connection in this graph, you only render the links who's length is only smaller than 200 pixels or 100 pixels?  What will we see?
      Let me show you what I saw.  Now, this is the same graph.  But now the clutter is gone.  You see convenience within the package manager.  It's about incredibly beautiful.  You can explore all these little fellows here and also see that the way it starts, you can still explore them.
      This visualization works really nice.  I'm using Mac here, and it's a very powerful computer.  But what about the our smaller friends?  The mobile phone.  Would it work in the mobile phone?  And does the mobile phone support WebGL?  So if you have iPhone or android with you, I encourage you to test me.  So grab your phone and go to this URL.  I will do it with you.
      So here you see a list of all package cheeseburgers manager's which are currently available.  Just for fun I will pick the largest graph.  The visualization of goal packages.  Which currently has 180,000 packages.  A little bit more than that.  All right.  So now you see the dots.  With one finger touch, I can fly forward.  And with two finger touch, I can fly backward.
      And using my mouse just regular phone just by rotating it, I can control the camera here like so.  So this is 200,000, almost 200,000 packages rendered in the mobile phone.
      So this was not released publically, and I'm not sure if you're experiencing bugs or anything, do you even see this on your phones?
      [clapping]
      Okay.  That's good.  I see the blank screen.  I think it's not good.  So this approach is really fast.  But how fast is it?  Can you see the numbers of really how many frames per second you're going to get from this approach to visualize large graphs?
      Let me show you the numbers.  On the next slide, we will see visualizations of popular package managers.  Side by side.  Composed with 65,000 dependencies, Ruby gems, and gold with 182,000 packages.  Ready?  So this is visualization package managers.  And this is FBS.  Most of them rendered at 60 frame per second.  So this is very, very fast.  And looking at this graph, several realizations came into my mind.  First the graphs are just absolutely amazing.  They have all sorts of little galaxies within them, little communities and behind modules, which are super fun to explore.  And second we need to visualize something else.
      Because it's are just not enough packages and all these package managers to get us to one million nodes craft.  But also all of these little dots on the screen, they're not just dots, they're part of someone's life April human being it just took part of their life and created the package and published it there.  So humans are very interesting species.  And developers also interesting.
      [Laughter]
      We as developers, we have all sorts of different connections.  Some of these connections are encoded on GitHub; right?  We follow each or.  And we want to see this following information.
      So our last stop today is one million node craft.  It took me several weeks to download the data from GitHub, and this is shown just first time for you here.  Nobody else saw this before.  So let's see what's going to happen.
      The data set is probably 20 megabytes, so it takes sometime to download.  And this is, ladies and gentlemen, the GitHub.
      [clapping]
      So let's explore.  All this white dots are just humans, which is incredible powerful thing.  So what is this large do the here.  Who is he?  Let's see if I can focus on him.  Come on.  Yes.  What about the this guy here?  Who is he?  This is TJ.  He has 15,000 followers.  And what about the this large stars in this cluster.  Who is this guy?  So I believe he's the one who started GitHub; right?  And what about the this guy?  This is Scott with 10,000 followers.
      So all these people here, they all work for GitHub.  Which makes me think if you want to have lots of followers in GitHub, you need to start GitHub.  And then similar, to have the package managers the satellites of people who follow just one package, here we have satellites of users who follow just one person.  So this is a cloud which follows -- who is this?  This is a cloud which follows Scott and -- you see there are lots of them here.  For example, what's this?  Followers of Stefan.  Now, let's enable links for a second.  With enabled links, you can see certain communities in the GitHub.  This is not seen before.  So all these people, they have similar mind followers.  But they follow most of the same people within this group.  And there are so many groups that are placed inside the whole GitHub.  You can see them all here.  And I think one of the largest surprises in the GitHub for me was this large green hair ball.  So all these people, they still follow each other and nobody else.  But why?  What makes is so special to these people?  Why do they follow each other?  I don't know.  And this visualization doesn't tell you.  It let's you ask these questions.  Why?
      So how many nodes does this visualization have?  Let me show you.  This graph has 1,117,000 nodes.  So, my friends, today we started our journey from request animation frame, and then we helped the force base out to escape the 60 millisecond window.  And then we defeated this hair ball monster and saw the behind communities within the graphs of package managers.  And final this visualization of GitHub concluding our journey into the graphs today.  But it will continue on this repository.  So thank you very much, guys.
      [clapping] 
