      >> Oh, there's a pirate.  Oh, my god.
      >> Wow, Jennifer.  That was fantastic.
      >> Thank you.
      >> So tell me about the poop map.  I'm not from San Francisco, so I'm not familiar with that project.
      >> The poop map maps a bunch of reports of human waste in San Francisco.  It was a hack week project.
      >> I like your -- yeah, I like what you're thinking there.  That sounds interesting.
      >> Thanks.
      >> I've got a question for you.  What is pirate's favorite letter?  Anyone can shout it out.
      >> R.
      >> No, it's C.  It's the C.
      >> Oh, dang it.
      >> You know, very important pirate things.  That was the only question I had for you.
      >> I'm sorry I got it wrong.
      >> Thank you, Jennifer.
      [clapping]
      Will Scott.
      >> Next I would like to introduce Will Scott, he is a grad student at the University of Washington in Seattle.  And he's here to talk to us about scanning the Internet with Node.js.
      "Scanning the internet with Node.js."
      By: Will Scott.
      >> Yeah.  So I'm going to sort of talking about a bunch of research that group at U-Dub has been working on for the last year.  And we've been doing a bunch of stuff with node that probably isn't really what it's meant for.  And one of the, like, sort of things that you can have in the back of your head about with, like, what the sort of, like, point at the end of this is this map, which is looking at, like, the top 10,000 websites where are their servers?  Where are the points of presence for all these CDNs.
      And, like, you can maybe think I can probably make a map that look like this by painting all of these and could geolocating them, but for a lot of these websites, they're not one server; right?  They've got a CDN, they've got different servers in a lot of different countries.  So figuring out where all of those servers are is suddenly a thing that's a little bit harder.  The CDN doesn't tell you this because that's their secret magic juice.  So what we get to do is figure it out for ourselves.
      So the project is called measure the Internet stars.  And one of the, like, things that we want into this with is, like, how much of this can we figure out from one machine that I control at the university?  You probably have dealt with things called distributed systems and know that they're a huge pain and, like, that's true.  But when you're thinking about distributed systems and you're thinking that server might crash and we need to be fault tolerant, that's different when the group is thinking about distributive systems, which means half are down at a given time and the other halves up don't have SSH working.  It's, like, plant lab is a thing that exists and sort of has been limping along, and it's just -- they ask different universities around the world and they're administered by a grad student.
      So we're going to try not do that.  So once I'm limited to my machine, how am I supposed to figure out, like, does Google have servers in Taiwan, and where are they?  This starts to be a little bit harder because if I just go to Google, I'm not getting the ones in Taiwan.  So we use a couple of techniques.  One of them is DNS.  DNS is the domain name system, and this is how we do resolutions.  So when I type in CascadiaJS do me, it gives me some numbers back, which is the IP address.
      And the way that system works with a great graphic from Wikipedia, is my computer is going to ask a DNS solver to do that lookup for me.  So when I say who is CascadiaJS?  And it's going to give me back the number.  And if it doesn't know, it's going to do the sort of multitiered lookup.  It's going to go to one of the DNS servers, there's a bunch of these around the World War II, and those servers knows who owns dot com and who owns dot org, and they will say who owns this, and that's registered to GoDaddy, and then it will go to one of the servers that's dub dub dub dot JS.com.
      And there's a bunch of things that will do this for it.  So you can get one when you plug in your computer, it comes with whatever your local IS pServer is, but you may have explicitly set one when you're not happy with that, maybe 8.8.8 is the Google one.  There's open DNS has some.  Comcast has its as many as that you may use if you haven't changed it.  But you can go out and say how many are there?
      And there's roughly 8 million of them, and you do this by just sort of asking all 4 billion IP addresses to resolve things for you.  And the 8 million of them get back to you.  And those 8 million are in 5,000 different AISPs, and there's ruffle is mean countries that have at least 20 of them.  And that's pretty cool because once we get 15 or 20, we can say not the server tells me things, but I can do some statical things and, well, everyone is telling me the same thing, so that's a good sign.
      So we're going to start scanning both to find all of these DNS solvers that will give us stuff and then also them to resolve domains for us so what do they see this domain?  Who do they think Google is, or any of these other popular websites are?
      I guess it's worth pointing out.  There are a lot of people who is having these things be open is a bad thing.  There are security risks here in terms of attacks that happen around DNS.  So when you do this, you will get complaints.  So this is, like, don't do this at home because there will be angry people be, like, you're making the problem worse.  But all the code is online.
      The other thing that we use as HTTP is we're going to try to resolve and make sure that some server is the actual server we think it is.  There's actually, like, on the order of 100 million IPs out of the 4 billion total space of IPs that are running Web servers.  So you've got, like, 2 percent or something like that of all IPs are actually running Web servers.  Which is pretty cool.  And then there's the much smaller HTTP proxies that will give you Web pages for any page instead of just, like, whatever it is that there are servers for.
      So we're going to try a bunch of this indirection.  It turns out it's basically as much trouble dealing with the distributed system in the first place.  But, like, at least there's only one server I have to SSH into.  Cool.
      So I'm going to, like, we've got this code that's going to run, it's going to resolve, it's going to, like, send a bunch of packets and get some packets back, and we have to understand what that means is deal with a bunch of data.
      So I'm going to spend a little bit of time to talk about IPs.  And maybe you'll learn a little bit more than you ever wanted to about IPs in the process.
      So this is an IP.  This is IP4.  This is an accuracy.  We've all seen these.  So an IPV4 address is four chunks, 32 bits, uninteger, they're longer and uglier but follow the same model.
      Bam back when we had limitless IP addresses, we had spaces sort of in a few different ways.  They would give out slash 8s or class A address spaces, which is just that first number to big organizations.  So Apple is 17-point something.something.something.  And we realize that we didn't actually have a infinite number of these, we had, like, 256 of them, so that wasn't going to scale.  So then we started giving out class B and class C.  So you've only got the first two defined or class three.  So you get 256 addresses.  And a few more years and we realize this isn't going to work because someone wants more than the 256 addresses but you don't want to give them 65,000 addresses.  So you can't do class A, B, and C.  So we got this thing called cider where you specify in bits, how many bits are the prefix and how many are the amount that you're allowed to control?
      So you've seen this probably as, like, your network mask or your subnet mask.  There's a lot of words for this, speaking of words.  A lot of jargon.  Sorry.
      But this last number is sort of specifying how much is owned by this organization, versus how much is, like, it can give to its individual computers.  So the 24 means the first three octets are part of this, like, group have IPs, and we're talking about 256, but now I can have a slash 24 for a little bit more or slash 27 for a little bit less.  And we have that ability to control that.  So that's how we allocate IPs today.  And, in fact, a bunch of these, like, original, like, class A addresses, they've asked, well, you need to give back some of those if you're not using them.  So now you have subdelegation.
      So what do we do with I Ps?  You've probably use Max mind, which is a geolocation table.  There's a couple of these; right?  So I've got an IP, I want to know where in the world it is.  I'm going to go to some Web service, and it will tell me.  This is great, except if I'm, like, writing a paper about it, and I need to explain, like, why I know where these servers are in this place.  I don't want to point to just, well, I got told that.
      So we have to dig a little bit deeper and figure out how they're doing it and how we can do the same thing.
      There's also two issues that we've run into.  One is a lot of times you have an IP that's actually in multiple places.  So this is any cast.  A you come relevant bunch of CDNs use this, and this isn't a thing.  That will tell you, well, this IP is both in the and did you say in Europe.  Oh, no.
      And for a bunch of core infrastructure routers, that's not what this is designed for, and you won't get any result.  So this works great for users who are visiting a website.  It's not going to work if you're going to try to figure out where the core Internet routers are.
      So how do IP -- how do I know where they are?  Someone owns these.  There are computers.  Presumably there is something out there that's the definitive thing.  It turns out that the technical incarnation of this world map of who owns what is BGP.  So BGP is how computers are going to route to each other.  So some organization is going to say I own these IPs, you should send me traffic that is destined to them, and people will do that.  And a lot of organizations are actually willing to publish their table of what they see around the world in BGP, and it looks something like this, which is complete random numbers.  But what's important is that first column is one of these subnets.  So that first line is saying 223.255.247. anything.  The next hop goes to some IP.  You should sort of send it over there.  And that long string of numbers on the right is the different organization IDs that its going to pass through with the final one being the guy who owns it.
      So we've got this nice mapping now of some network being owned by some number.  That number is called the -- the autonomous system number.  It's the official registration that Comcast or any of these ISPs have; right?  They've got a number, that number is registered in some country, and then it's registered with the international organization that registers these things.  So we can actually say, well, okay.  This set of IPs at this time was being routed to this IP in the country.  And that gives us a first pass at what country should we expect these IPs to be in?
      The problem is this table is pretty big.  It's roughly two gigs and there's 21 million lines.  So we have to, like, deal with it.  The other thing that we care about is when I'm looking for the specific IP in this table, there's going to be a lot of lines that match.  For instance, that example of 8.8.8 that I gave, that's been subdelegated to Google.  So Google owns that small little 8.8.8 whatever part.  But that's within this larger 8 dot things that was assigned to level three.  Or it was assigned to level three, but it's controlled to level three right now.
      So I have to find the more specific ones, so there may be other things that match, so I have to get through a few entries to get to the one that I care about.  But this seems doable.
      So let's go build a table in JavaScript that can do these lookups.  We would like it to be able to do that quickly because we've got a lot of IPs to get through.  Hopeful we would like to get this to be, like, pretty quick as well.  It seems possible.
      So step one.  How are we going to read that data?  If I just call read file, that's not going to work.  And luckily, you know, I think we all know this.  Streams are the best.  We can make a stream, we can pipeline by line because it's just all line by line.  And we can pull out the things we care about, and we're good to go.
      Streams are great.  And if you want more streams, I highly recommend stream adventure, it's a great intro substack on streams.
      So we've got data in.  Now we need to figure out how we're representing this data.  And this is the part that's counterintuitive to me.  So I showed you that tree and that initial let's get this a map so we've got our general prefix and then we're going to put the more specific prefixes in it.  This is fine and we've got a key and an object.  And this works pretty well.  The final JSON of this thing was 30 megs.  It took two minutes to, like, push through, which isn't bad, and it was super fast to do the lookup.
      And one thing that was annoying every time you load that 30 Meg thing into node, it took a second, which wasn't calibrate.  And also this table was 30 megs, which was pretty big.  Because, like, the maximum database I can download is two megs, so I was not happy about that.
      So one thing that we really was a lot of the effort here is going into making these objects.  And you don't necessarily need those.  So we tried to flatten it.  So we're going to have all of these just be in one map like this.  And suddenly your table goes down to 13 megs, which sort of makes sense; right?  We've got be ridden less text, less letters.  But your build time goes down to 20 seconds and your load time goes down to half a second.  But your look up time goes up a little bit because you have to do more lookups in your big table that takes sometime.
      And then the only other thing that was slow here was that 8.0.0 to timely calculate all of these prefixes as we're starting with our specific IP and saying okay.  Well, is there one that's slash 31?  Is there one that's slash 30?  Slash 29?  You have to keep recalculating that number, and take it back into your IP address format, go back to the number, and if you just leave it all in numbers, you can make your lookup time be fast again.  But it looks ugly.  But that's fine.
      Cool so we've got a thing that's fun and then this suddenly is like -- I don't know one of those, like, algorithmic puzzles that people get really excited about.  So, like, I've had people in the lab just spend a bunch of time finding all of the duplication in it and writing the thing that makes it smaller.  And we've gotten it down to two megs, but if you are sending it over the wire, it's down to 400K for the whole table.  Because there's all of these crazy math things that you do with this because this is a problem that I can compress in one ways.
      So we've got IPs figured out to some extent.
      So let's talk about connections.  Making a lot of connections.  And, like, we've got this core, which is we're doing a ton of connections.  We're looking at the top 10,000 domains, and we're looking at them against 8 million open servers, so you can do the math, but that's a lot of billions of IP, like, data grams that we're sending out.  These DNS queries and responses.  When we first got, like, a server to do this, we accidentally broke B dubs Internet because we were sending to them.
      So since then, we've gotten our own, like, dedicated link to the Weston downtown, and we're not going to take down the connection begin he, which is cool.  But for that core piece of sending a bunch of packets, we don't want to maintain state, and that is done in this Z map that already existed.  But we're processing the roughly 400 gigs of response that we get each week with a node stream pipeline.  And there's not, like, that much beyond streams that you need to just do this reasonably.  Once you get up to enough hundreds of gigs, you probably are going to realize that you want to use multiple corresponds, and you're going to split it into, like, a few differed node process that each take a slice.  But other than that, you're good.  And so it's going to look something like I'm going to map my incoming stuff, which is what we're using fab cons, so we're going to fetch a bunch of them from the IPs that we found are servers.  And we're going to just map it through something that does the request.
      One thing that it didn't give us is the ability to chaos our currency level.  You've got a high-water mark in this concept of streams in terms of how much stuff is flowing through your stream at a given time.  But we ended up with the more control over that.  So we ended up making a map where we could set how many things are going at a given time.  And that ends up being, you know, five lines.  And so this is, like, we're going to fit into this fun world of doing one thing well.  And we're going to end up with a bunch of NPM modules that end up making this thing not only reasonable easy to understand, but also it's a really cool thing for undergraduates to come in for a few months or interns who come in are able to come in, own some module, make it work, and then they've got that thing to, like, show off later.
      So we found that pretty cool.  The other thing that we use everywhere is a thing called progress bar stream.  Which makes little progress bars show up whenever we do things so that we can tell, like, is this a thing that's going to take a minute or hour or ten hours?
      And between those things, like, you're good to go.  You can, like, I can talk to you about, like, memory exhaustion, which happens if you do things wrong, like, you make a man that is going to, like, grow.  But you see that by running top and be, like, oh, yeah, that's about to run memory.
      And other than that, use some streams.  There's a thing with all the data if you want to play with data yourself, we've got both the original data and then the, like, exacted and aggregated down to insane amounts of data on and you're welcome to play with the IP stuff for, like, some of these fun progress bar things.  So thank you.
      [clapping] 
