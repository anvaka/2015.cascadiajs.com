      Hello, CascadiaFest! The livestream captions can be followed on your handheld devices at 2015.cascadiajs.com/captions.
      [Captions provided by @chaselfrazier @whitecoatcapxg. Thanks to our sponsor @mobify!]
      >> All right.  Good morning, Cascadia.  We made it to day three.  So I'm Ryan you have now made it in case you don't know where you are.  Server day.  The third and final day of CascadiaJS.  I just want to say thank you for being up this early.  It was one heck of a pool party last night.  So good job for being here.  I hope you got enough coffee, got enough food, and then we're going to kick off and get into just an awesome phenomenal day here.
      So first thing.  Volunteers are wearing the orange.  So if you need something come up, need to talk, need directions, just flag someone down in the orange shirts, and they're probably going to be a volunteer.
      One thing.  I would like to reiterate again because we have a few folks coming in just for today, seven day, I like where your head's at, we have a code of conduct that we take very seriously here.  We have a sign outside, we have a phone number to call in, you can approach any of the volunteers with any issues that come up, but we take that stuff seriously.  We want to have a warm, friendly, and tolerant Cascadia because we're all awesome, so let's just keep it awesome and just keep that in mind.
      So today we have some amazing, exciting talks.  We have a couple of the good for you ones.  Learning about time.  It's always a pain.  Security.  You should know this stuff.  As well as we have large-scale, we have small scale, we have the command line, and of course robots because robots.
      The other thing is we have two really neat workshops going on as an alternative to some of the tracks which is WebRTC, really, really cool, as well as mobile testing, and that type of testing is so hard.  So with some talks, workshops, we're going to have a great amount of fun, and we're going to have the final party in here, which is going to be awesome as well and hopefully cap off a great conference.
      So with that, I would like to introduce the MC, the ever wonderful, Marcy.
      [clapping]
      >> Good morning.  So I've been a residential of the Pacific Northwest my whole life, so I am very excited to be here.  I'm seeing the final day of CascadiaJS server day.
      As a Web developer, I started more on the client side, but server JavaScript has crept into my workflow, to dependency management, packaging projects so you don't have to go to the software development team to package your project for you.  Running browsers or building modules, delivering modules, building robots, node copters, connect jewelry.  The list goes on and on.  So obviously this is a rich topic, and we're going to have some great speakers today.  I want to give a shout out to HBO, thank you for sponsoring these talks because this is what gets the speakers in front of you today.
      So without further adieu, I would like to introduce Jennifer Wong, she works at Eventbrite, and she's here to talk to you -- her talk is called I think Iran what you're talking about.  But I'm not sure.
      "I Think I Know What You're Talking About, But I'm Not Sure."
      By: Jennifer Wong.
      >> Don't look at my notes.  So as Marcy said, I'm presenting today I think I know what you're talking about, but I'm not sure.  To start off, I'm Jen, I'm a self-taught front-end developer, and as of a couple weeks ago, I became a engineer at Eventbrite.
      You may also know me as the creator of human wasteland, also known as the poop map, particularly for those of you from the Bay Area.  You may also know me as a creator of another project calls developers, developers, which is a dedication to Mr. Steve Ballmer.
      So all of that is a long-winded way of saying I write code for a living.
      So a couple of disclaimers before I get started.  There are going to be a lot of animated GIFs in this talk.  And there might be a few errors in my talk.  So if you hear some of those errors, you might be a little bit like this.  But before you starlight to get a little bit like this, let's talk about it.  Let's talk about it after my talk.
      So let's go.  So as I said I'm a frond-end developer, somewhere engineer, programmer or whatever else you might like to call me.  So some days when I'm looking at my computer, I feel a lot like this.  And I think you guys can probably empathize.  And sometimes when I'm in conversations with other developers, I feel a little bit like this.
      So Phil Carl once said that there are two hard in things computer science.  Cash evaluation and naming things.  And we can see that and some of the programming we have in Web development.  So here's a bunch of words I've seen before just in my general programming life, and a lot of them made absolutely no sense to me.  And when I hear people talking about them, I'm, like, I don't know what you're talking about.  I've heard that word before, and I think I might know, but I'm really not sure.
      So when I ask somebody in conversation, a lot of times I get this look.  And that makes me feel like this.
      So, again, you know, our conversations can get really complicated.  Our jargon tends to make sometimes no sense and a lot of our words don't have relationships to the history of the word itself.  So today I'm going to talk about a few of those words so you guys hopefully in conversation are a little bit less like this.  And the next time you hear those words you feel a little bit like this.
      So first up.  Parameter versus argument.  What's the difference?  Is there one?  So to find out that answer, I went to Google of course.  And you'll see a lot of people are wondering that question because the third query down you'll see people are discussing -- looking up the difference between parameter and argument.
      So here I have a function I created called shark.  And below at the bottom line I'm calling shark with the string left.  So how many people think that the parameter is in the first line and it's that variable side.  Raise your hand.  And I'm just going to raise my hand both times.  So I'm not giving you the answer.
      And how many people think that the parameter is on the bottom line that string left?  Raise your hand.
      Okay.  Well, I'm not going to tell you.  But let's keep going.
      So parameter in the online etymology dictionary, which is essentially the history of words says that a parameter is a measurable factor which helps define a particular system.  And that leads me to believe that it's probably the variable that's in the function definition.  But when I look up argument in the online etymology dictionary, all I find is definition, a definition discussing how people are arguing with each other.  So that doesn't really help me define that in computer science.
      So I keep going and I check out Wikipedia, and I look up computer programming, and I see that the term parameter, sometimes called the formerly parameter is often used to found in the function definition.  Well, argument called sometimes the fuel parameter, refers to the actual input past.
      And I think most of us know what can infer from this definition when an argument or a parameter is in that case.  But then I also look at it, and I wonder why didn't we stick with the terms formal parameter and actual parameter?
      So to figure that out, I've got to go down the rabbit whole a little bit.  So I started looking up parameters and arguments in math.  And here I find that a function definition can also contain parameters but unlike variables, parameters are not listed among the arguments that the function takes.  And it's, like, huh?  What does that mean.  So I was, like, Wikipedia, go on.
      And they say that the variable X designates the function argument but A, B, and C are parameters.  And you'll see in that quadratic function, for those of you who remember high school math, that X is the argument and A, B, and C are the parameters.  And I was, like, wait a second.  So in math, A is the parameter and that first function but then in computer science, bar is the parameter on that second function.  And this is how I felt.  It's, like, wait.  What?
      So here's how I describe it.  The dog is a parameter.  The football is computer science.
      [Laughter]
      When the parameter hits computer science, it gets flipped on its end, and it's a different definition.
      So my take away from all of that is that at least in computer science that we know parameters help define a function and arguments are passed into a function.  So here's the answer.
      Parameters up on top, arguments down in the bottom in the function.  But all that being said, we use parameter and argument interchangeably.  So that was easy; right?
      Okay.  Next up.  Scope.  So when somebody asks me to define scope for them, I don't know bugs, but this is how I feel.  Like, I really don't want to talk about scope.  Please don't make me talk about scope, but I'm going to talk about it today.  So first let's talk about lexical scoping.  So I went to Google and I saw that lexical scoping, sometimes known as statistical scoping is a programming use with languages sets a scope range of functionality of a variable so that it may only be called within the block of code in which it is defined.
      Okay.  So that definition is a little bit crazy.  I don't know if you guys notice but in those parentheses in lexical scoping and static scoping.  Scope to range a function altitude and call to reference.  So just in one definition, we see that terms are equal to each other.  Them the same thing but can be equally confusing because we're just using them all the time.  The other thing about that definition is they actually use scope in the definition of lexical scope.  So you need to know what scope is before they can even define lexical scope for you.
      Is let's break it down a little bit.  I'm going to talk about scope, which in the online etymology dictionary, again, says it is an aim, person, objecting aimed at target, which doesn't help me define that in computer science.  So I keep going and check out scope and computer science and read that a scope is a part of a program that is or can be the scope for a set of binding.  A precise definition is tricky.  See below.
      [Laughter]
      Okay.  So let's see below, guys.  Okay.  So I keep scrolling down the page and I get to scope and I see in computer programming the scope of name binding and association of a name to a entity such as a variable is the part of a computer program where the binding is valid.  Where the name can be used to refer to the entity.  And because I already what an scope is, and I'm sure most of you guys know what scope is, probably at least loosely, this definition makes sense.  However, somebody who has never heard of scope before reads this definition and they feel very confused.  So I would say that this definition is it's okay.  It's not bad.
      So I keep reading down the page and get to scope again, and I see that the strict definition of lexical scope of a name or identifier is unambiguous, and I'm, like, thanks a lot, Wikipedia.  Unambiguous.  Okay.
      But then they say it is the portion of source code in which the binding of a name of a entity applies.  And I think that's the most basic and easy to understand definition of scope I've found so far.  Why wasn't it at the top of my article?
      And it was changed from its 1960 definition.  And I don't know how many of you know what Algol 06 is, but it's short for algorithm language of 1960 People's No. and it's the first language implementing function definitions with lexical scope.
      So we've had this definition since 1960.  And yet scope is so complicated to define.
      All right.  Let's go on to lexical versus dynamic scope.  So, again, in this Wikipedia article on scope, we see that they say lexical scope is the main focus of this article.  But dynamic scope understood by contracts with lexical scope.  So, in other words, they can't even define dynamic scope without first defining lexical scope.  Are you guys still with me?
      So lexical in the online etymology dictionary means pertaining to words, and that doesn't quite make sense to me as related to scope.  So I look up dynamic and I see that dynamic pertains to a force of motion, the opposite of static.  Which I found interesting because in the earlier definition it can also be defined as static scope.  So I keep going in Wikipedia to find on you the what the difference is between these two.
      So they say for most programming languages, part of the program refers to the portion of the source code or area of text and is known as lexical scope.  And I found that interesting because we saw that lexical means pertaining to words.
      So I keep going, and I see that in other languages, however, portion of the run time or time period during execution, and that's known as dynamic scope.  But I keep reading and then I see that both of these terms are somewhat misleading.  They misuse technical terms as discussed in the definition.  I'm, like, wait -- was what I just read wrong then?  And I keep reading and it's, like, but the distinction itself is accurate and precise, and these are the standard respected terms.  And I'm, like, maybe it was right?  I don't know.  So I keep reading and I see in practice with lexical scope, a variables definition is resolved by searching the containing function.  Whereas with dynamic scope, the calling function is searched then the function which called that calling function and so on.
      And I find that this is probably the clearest definition of lexical scope versus dynamic scope for me.  And all that being said, who cares about dynamic scope.  This is a JavaScript conference.  So I'm going to just quickly define lexical scope as I see it.
      My friends wanted to have lexical scope as a bunch of rooms and you sit inside your room but on anybody can see inside your room, but you can see outside of it.  So here I say that the box is my scope and the orange cat can see the white cat, but the orange cat can't see the white cat.
      And next up recursion.
      It means from the 1600s a running back or return.
      And I look it up in Wikipedia and I find that the most common application is in mathematics and computer science in which it refers to a method of defining function in which the function being defined is within its own definition.  And I was, like, wow that's a lot of, like, defining, defined, and define for just one definition.  So I was, like, okay.  Let's try to find something more clearer.
      Specifically this defines an infinite number of instances using a finite instruction that some instances may refer to other instances but in some way that no loop or chain can occur.
      Let's keep going.  So, again, in Wikipedia I see that in mathematics and computer science a class of objects or methods exhibit recursive behavior.  Number one a simple business case or cases a terminating scenario that does not use recursion to produce an answer.  And a set of rule towards that first base case.  And, again, because we already know what recursion is, this definition makes sense.  But somebody coming to this word and definition probably who doesn't know what recursion is probably feels more like this.
      So I define recursion in a function that calls itself.  And that's a way that has been defined to me.  However, some people want to get complicated with it.  So when they're explaining it to me, they decide to bring up the Fibonacci consequence, and I don't know about you guys, but it's been a long time since I took math, and I don't even remember what the consequence is.  So I look at this function and I hear about the Fibonacci consequence, and this is how I feel.
      So another friend of mine brought up factorials, a lot of them learned in elementary school and that's a great version.  And when someone brings up factorials with recursion, it sounds like this.
      And concatenation it is a linking together or link together a chain.  And I was, like, oh, my god.  We have a word that actually meant in the 1600s and we're using it in the exact way.  That's awesome.  But most of the reason I'm bringing this up is because it has cat in it, and today is my cat's sixth birthday, so happy birthday to my cat.
      Okay.  Now.  Acronyms.  I don't know about you guys but there are a whole lot of acronyms out there that get really confusing to me.  The first of which I get confused all the time and those are CRM, CMS, and CDN.
      So just to clarify, CRM is a customer relationship manager.  Kind of like sales force.  A CMS is a content management system.  Kind of like WordPress.  And a CDN is a content delivery network.  Kind of like Amazon cloud front.
      And next up is Sass versus Sass.  Please clarify to me when you're talking about these what kind of Sass you're talking about.  Are you talking about software as a service, like, sales force, or are you talking about syntactically awesome style sheets, the CSS extension language?  I don't know.  But I'm going to get Sassy about it.
      Next up is DOM.  DOM has always been kind of confusing to me.  This is Grazer Dom, which is a chapel located in also the, this is DOM, the Indy band.  So this is the DOM, which is located in the Alps, and, again, we see the term Sass in this definition.  So there are a lot of things called DOM.  But the DOM that we are often talking about is the document object model.  And the document object model is defined by Wikipedia as a cross platform for representing an interaction of objects with HTML, XHTML, and XL documents.
      I'm, like, that kind of makes sense, but I'm going to search Mozilla developer network and see if I can find a definition.
      And they say that the document object model is a programming interface for HTML XML, and SVG documents.  It provides a structure representation of the document, a tree, and it defines the way that a structure can be accessed to programs so that they can change the document structure style and content.
      I'm, like, oh, that makes a lot more sense.  And even better, NDN provides a nice little sketch of a DOM.  So I'm, like, yay.  DOM.
      And now Gooey and CLI, or what I like to call Klee.  Because if we call them, Gooey, why not CLI as well?
      So when I hear Gooey, this is what I think of.  I also think of Gooey ducks, which is a bivalve.  And Geoduck is weird because it's not spelled the way its pronounced.  Similar to GUI.  And when I hear of CLI, I think of Paul CLI, who was a parent in the late 1800s.  But I think most of us know that Gooey and CLI as I like to say is a graphical interface and was used in the steep learning curve of command library interferences, which require commands to be typed on a keyboard.  So the next time you're talking about Gooey, and somebody is giving you the look that I don't know what you're talking about, please tell me it's the graphical user interface.
      And lastly AJAX.  I think AJAX is a totally outdated acronym.  But who even uses XML?
      The other thing about AJAX is the jQUERY method has an object to sink to false, which means you could be running synchronous JavaScript in JSON.  Just saying.
      So in conclusion, oftentimes when you hear these words in programming computer science conversations with your fellow developers, you don't really know what they're talking about.  You have some concept.  But when you start using them in practice, you're, like, oh, I get it.  And you just understand it immediately and because you just get it, it makes it really hard to explain to somebody else.  And I understand that difficult, but I implore you to take the time to really explain those concepts to other people, especially when you're in a big group and someone's given you a look like they don't understand.
      Don't feel like this if somebody asks you a question.  And if you're in a group of people and somebody asks you a question, try to be a little bit less like this.  Just be a little bit more like this.  Because it's really difficult to explain these concepts and we really need to help each other out.  Let's take a look at this video.
      So you see 12 there.  I don't understand what Gooey is.  Everyone around me is talking about Gooey.  What is Gooey?  And another number 12 comes over and is, like, let me explain Gooey to you.  Gooey is the graphical user interface and other number 12 is like I understand now.  That's what Gooey is.
      So when we're all a little bit more like this, helping each other out, explaining what gooeys are to each other, we can all party together in the computer science jarring object land.  Thank you.
      [clapping] 
