      >> Thanks Adam.  That was great.  I had no idea that regular expressions are that vulnerable.  Kind of important if you're running regular expressions to know those things.  How do you feel about the throttle everything security.  IE rate limits as defaults.
      >> That's a good idea.
      >> Yeah?
      >> I don't know.  I haven't thought about it much.
      >> Can you elaborate.
      >> Any input validation, anything you can put control over what's coming into your system, the more control you can have over that, the better.  You know, we see -- I don't know what the throttle -- you know, rate limiting.  Usually you can put in probably a better control, like, that's, like, a last ditch.  Like, you should probably have something better in place.  But I don't know.
      >> Put you on the spot.
      >> Yeah.
      >> That was a pretty good answer for putting you on the spot.
      >> I could talk longer.  But I spoke.
      >> That was a great talk.  So I would love to hear more on that.
      >> Thanks.
      [clapping]
      >> So next we have Parashuram N he's from Seattle as well, and he's here to talk about automating Web performance.  I'm excited to hear what this means.  So fill us in.
      >> Thank you.
      "Automating Web Performance Measurement."
      By: Parashuram N.
      >> As she said, I'm going to be talking about automating Web performance measurement.  Yeah, it's actually a pretty hot thing to take in.  So let's start with a simple story.  Before we begin, let me tell you how all of this started.  So before my current job, I used to work at a enterprise company for some reason I couldn't find a picture of my boss and me working together, so I just picked one from the Internet, but that's -- let's assume that guy there is my boss, and that would be me.  So one day my boss comes over to me and tells me -- oh, wait.  But this is an enterprise, let's add a little bit of spice to this.  That's it.  That's my boss.  That would be me.  This is going to be interesting.  Anyway the boss comes to me and tells me, hey, I'm going to be working on a awesome product.  He says that the product is I'm going to be explosive, it's going to go wild and stuff.  And I'm, like, finally I get to make a mark in the world.
      He just says, hey, you're probably going to work on the website of the product.  Fine working on the website of the stuff is also a big deal.
      So anyway a couple of developments go by, I do a whole bunch of code, look at all the places, the typical things that developers do.  And after a couple of can deployment cycles, my boss comes to me and tells me -- hey -- oh, no, wait scratch that.  He said the fight feels slow.  So I was, like, slow.  Why is that inspect I was not sure what was going on because I didn't do anything to make the website slow.  I was just writing code; right?  I wasn't sure what was going on.  So I invoke the force that I had in my, and I'm sure the force that all developers have in them.  I invoke the force and ask the force how do you make a website fast?  The funny part is I actually get the answers right there.  I don't even have to go to schools.  I just had the answer right there.  So that's a good checklist.  I started working on the checklist one after another.  It's one through six.  Good.  That's easy.  But being the curious guy I was, bad idea.  It took a couple of days, but I actually learning interesting tools, about Google speed, a whole bunch of tools.  Put all this knowledge together and did something with the website.  Now, I was not happy and my boss comes back to me and this is kind of what happens.  And he tells me, hey.  The site still feels slow.  And that's when figured his @he must was not on the word slow.  Emphasis was on the word feels.  The site was jittery, and that's what I realized something.
      Here's the graph for my presentation.  So here's what happens when a user comes to your site.  They spend some time on your site and then they interact with your site.  That's basic; right?  So it's pretty much waiting for the network, something you probably don't control.  And then we always try to minimize the generating time and all try to expand the amount of time that they spend on the site and give them a good user experience.  It's all network performance, not much has been done actually on the experience part of things, and that's what we're going to be talking today.
      Looking at making the site smooth, fluid, quick, and easy to use.  So I probably can't because through all the single slow code that I added to my website, but there was one interesting feature that I added.  And believe me, I'm not making the G number up.  That was the number there.  And for those of you who know, 1138 is apparently special for George Lucas too.  So the feature is I had to add was I apparently had to add a reading progress indicator.  Now, you might ask me what that was.  It's basically that thing that you see on the corner.  And the box specification said that it needed to do three things.  It needed to tell the user how much was scored.  Needed to look at the position, and it needed to save the position so that when the user comes back, they start back at the same place.
      But you might now ask me there's a thing called a scroll bar right next to it.  Shouldn't you have kind of used that?  But, well, you know, I was a good developer, I didn't question the manager.  I just went with it.  And, hey, I get to write more code.  So, hey, why not.
      And those are also the days when I was just out of Java, I work I didn't know JavaScript, so I just learned jQUERY, and how hard can it be; right?  So I figured there was this thing called a scroll handler.  And what I needed to do was find out how much scroll the scroll the user did and find out how much the scroll has happened.  But I figured the double edge case,it to put in a hack and don't even worry what that code does because I have no idea.  I kind of -- the junior programmer and me who wrote that code.
      And then I basically had to add how much scrolling would happen.  Position it from the top and just -- I mean this code doesn't really look that bad; right?  And that's exactly what I thought.  But then after looking at -- after reading articles on Google, taking the course on -- taking courses on rendering performance and stuff.  I figured this probably has a pretty bad impact.  Now, I opened the profiler tools as talked to am in the courses.  And surprisingly what I noticed is all the tall buildings you see there at the top.  They're almost running 60 frames per second.  And that's supposed to be because that's supposed to make your website slow and jittery.  And if you dig a little bit deeper, there's a whole bunch of random events that the browser is doing.  It's like the browser is in a candy shop and doing all sorts of things.
      So that was bad, bad, and I looked at how to fix this.  And what I ended up with basically -- so here's the code that was there.  So first thing let's cleanup our code.  So that whole junk, I just removed it.  I cached my jQUERY selectors and put them there.  The second thing is apparently you shouldn't use Java, you should be using CSS selectors.  And finally any heavy work that you do should be in the animation frame.  So that's exactly what I did.  And now when I started doing profiling, look at it.  Not many of them are actually at 60 frames per second, which actually means my site is smooth.  And it also means that just a couple of the things that the browser is doing that's apparently good for the browser.  So all of this was really, really complicated stuff for me.  This was the first time that I first optimizing it.  And the fun part is I got to do it every single time.  So every time I wanted it to, I had to change the code.  And that's fun, isn't it?
      So we change our product -- a product like what we really wanted.  You might be curious what happened to the product, apparently it died of flaw and didn't work out very well.  So it got approved, and then I was happy, it was a great product.  Or at least a Web page for a great product.  But whatever.  And anyway that's when I started thinking.  Don't ask me if I was not thinking doing the development cycle, that's a different question.  But that's when I sat down and had sometime to think.
      And what I did was this.  I had to do this profiler process every time.  Every time I wrote the code, I would do the profiling or otherwise he would ask me the site is going slow, and I would have to do the profiling.  So it's hard.  Also all the other back-end features or the other important features, they had desk cases.  Most of them were running through a process, there are a billion of them today.  And then every single comment, you actually knew who broke.  So as a feature if anyone breaks a feature, that you know.  But what about the performance?  I couldn't really find anything.  And somewhere on the Internet I also heard performance is a feature.  Well, if it is a feature, why not do not we have integration and run it every single time?  That's a good question to ask.  And that's when I figured I knew what the answer was.  The answer is automation.  It's kind of ironic that this cartoon came in around the same time when I first thinking about automation.  But automation was the answer, and I was going to do the automation part.
      So what exactly was I doing through this profiling?  What I was pretty much doing was one scrolling the page.  Second collecting the timeline data, and then going on fixing it.  How hard is it?  It's just three steps.  What we saw yesterday.  Draw the two circles, do the two steps.  So that's exactly what I'm going to be doing.
      So step one.  Scrolling the page or more in line with the team of the presentation.  Episode one.  Scrolling the page.
      So scrolling the page isn't that hard.  It's just picking up -- inside of the animation frame, you just scroll to a position, and you repeat that over and over again.  This shouldn't be hard.  So let's actually see if this works.  Oh, yeah, this is when I show you the demo.  So I open my browser, I have a Web page open, which can be scrolled.  I have my developer tools on, and I copied the code already.  I just hit enter, and my hands are up here, it's automatically scrolling.  That's the first of automation.  That's exactly what we wanted; right?  So that's a good start.  The thing is I actually don't want to keep opening the browser every single time.  Well, there's an answer for that.
      Let's invoke the force and ask how do I automate the browser?  Well, there's a lot of answers but, hey.  This looks like this is something -- it's chromium, Selenium, chemistry.  So let's start using Selenium, and what I've done here is I've started the Selenium server, I'm kind of cheating and using the Chrome version of the Selenium server and I've picked up this model, that was written by Adam somewhere in the back.  And I just -- and this is very simple I just start automate my browser.  All I would need to do is -- I have an object called B, which is called browser, and I just say in it, and I would give it a content option.  And what this would typically do savings and loan open up my browser.  And just go to the blank page.  So let me actually close this guy.  We don't need this guy anymore.  So Chrome just opened and what I'm going to do is me dot get.  2015 dot -- and there you go.  So that brings up CascadiaJS.  And then what I had to do was exit the script that was called scroll and the scrolling is happening at the background if you notice.
      So that's simple.  All of this is just JavaScript, this is just node, so I can take all of the things that are on here, write it into a single program and run them; right?  So that is good news.  Now the question is how do I collect the timeline data?  If I want to automate it what I would have to be doing is open up the developer tools like this, go to the timeline and start collecting it.  All apparently Google Chrome timeline has a program that I could use.  So that's one opposite.  Or surprisingly what happens is -- did I close the browser.
      So there's this thing called get log types.  And, hey, this has a log type performance.  Isn't that exactly what we want?  So I would say, hey, me dot log.  The log type I want is performance and then once I have this, this is a performance so I have to do these.  But if I do this, it's going to wait for a really long time and then give me all the performance data.
      What this typically does is picks up all of the information that the Google Chrome timeline uses and then just dumps them as a big, big JSON.  Big.  Done?  Yeah, done.  So it's actually a pretty huge JSON.  And it's actually pretty simple.  It's just a JSON string that has events, like, pains, layouts, pretty much exactly what you see in the timeline.  It also has interesting events like benchmark, benchmark instrumentation and when is a frame drawn on the screen.  When is the screen up decade, what is the pixel change, et cetera.  So apparently it has all of this data.  And step one we open the browser, step two we scroll, and three we parse the data.  So I'm not going to sit down and parse all of this.  I cheated and used my space time capabilities, and I'm going to show where I parsed the data.
      So basically what I do is start all the events I get.  And once I've started, I run another hydration, and with this hydration, I'm picking up all the events I'm interesting in.  So pain, layout, style, et cetera.  Write them down, and then get started.
      So I have all this done, and I'm not sure this code is going to be interesting because it's just a set that I did with the JSON format.  But what's interesting is what happens when it runs.  So let me close this guy.  And let's say we run it on Cascadia's website.  What douse?  You guys think it's going to be fast?  How many of you guys think the Cascadia website is fast?  I believe in Cascadia.  So let's see.  I have no idea what the results are going to be.  So what happens if you see here the browser opened up.  It started running the scroll, the scroll seems to be decently smooth, it has a whole bunch of big pictures.  That is a little bit of a jitter, but I'm hoping that jitter shouldn't matter, and I should get almost 60 frames per second.  So it's getting that performance log, and it got the results.  I don't know if you can read the results here.  But they're encouraging.  It's almost 52 frames per second.  If you want to calculate frames per second, it's almost 60 frames per second.  There's a little bit of a difference here because JavaScript animation frames per second does not room.  So there's a little bit of room, but not that bad.  And this is the browser had to pain for the entire scroll.  These were the -- they were, like, no expensive event handlers, which is good.  But, you know, what's funny.  It's good to see all of this in isolation.  But for the creditor of the guys who actually wrote the website, why run it -- if anyone wants to try it on their websites?  Okay.  No one is coming forward.  But nothing against Amazon, but let's say Amazon.com.  I mean this is pretty much what my wife uses all the time so Amazon.com.
      It does the same thing.  Opens up the browser.  Oh, today is prime day I didn't know that.  Oh, no, it's not today.  It's still loading.  And started scrolling.  Good.  That's a good news.  There's a lot of images, which is probably going to make it a little bit janky.  And going back, it's getting the big performance log in.  And they're out of memory because the performance log is huge.  And they're also seemingly doing a pretty good job.  53 frames per second is actually pretty decent.  That's also good.  Can someone tell me a website that's actually pretty bad.  Any website that you guys have worked on and you know is pretty bad?
      I have worked on that, so let's try that.  I have no idea what that's going to be.  I can tell you it's going to be bad.
      [Laughter]
      Yeah, that survey was a bad idea.  Nope.  Not bad at all.  53 frames per second with the survey is actually pretty decent.  Anyway.  We can do this all day long, but let's get back to our presentation.
      Anyway so what we just did to just summarize is we were at tools, I just packaged all of these things in a one single tool NPM.  Just as developers are really bad as naming, that's what I did.  Browser buff, unfortunately.  It actually is open source, and it's best on chromium performance suit.  So chromium actually has this written in Python, I took that to Node.js.  It not only runs scroll, but because it's based in Selenium, you can do click a button, go check out the page, you can use it for it, and it's in Chrome, Safari, Firefox, i.e., a whole range of browsers with the data that you get.  And I definitely need to give a shout out to stop quote, because it was a CSS framework that actually had a set of performance benchmarks.  And then integration.  How can you use this?
      If you guys use Angular, you can -- there's a plugin for this where you can run your tests and say, hey, am I getting 60 frames per second?  You can run for every deploy and use these metrics into graphs and look at what trends exist.  I ran these on a whole bunch of websites, on a whole bunch of frameworks, and I got a lot of data.  And let's actually look at some of the data that I was able to look at.
      The fast one is I compared JavaScript frameworks.  Now, before I get in one.  This is a very bad idea.  You will get a lot of hate mail.  A lot of hate tweets on the Internet.  Do not do this.
      [Laughter]
      So anyway, regardless I did it because I mean I could do it.  That's why.  So I compare Angular and react using this framework called DB monster.  So those of you who have seen the react stocks, there was this DB monster react, they were the first to compare it.  Don't blame me.  So the fun part is there were no real numbers.  So what I wanted was I didn't want to see a video and say, hey, this is faster, this is slow, I wanted numbers.  So there were some really interesting numbers that I want.  I have the exact analysis in the blog post there.  But what it actually shows is react was the fastest.  And this is before ember had the new rendering engine.  So react was the fastest, and it had a lot of eventing done.  So there was a lot of JavaScript manipulation.  But there was, like, almost no layouting and no painting.
      And ember is good too.  Ember was working really, really well, and Angular defense it was doing too many.
      And it's going to lead to a religious war, so I actually learned from that.  And I figured, hey, let me try to help these frameworks by running the tests, not comparing one framework with another, but one version versus another.  So I did the site called Web GitHub.  And Web hyphen -- on right now just these four.  I hope to add more, but the graphs that you see are pretty interesting.  I actually ran it from version 1.1.1, 1.0.0, to all the way.  And you can see they added a whole bunch of competence in their tame frame and how the scope is started to grip.
      And the interesting thing is ember.  So this is the results from ember.  I got lazy, and I started from 1.12 to the current version.  And what you can actually see is that part there is the new performance engine.  That's glimmer.  I could not find numbers anywhere, but there's approximately a 25 percent increase in the performance to the engine.  The another thing that I actually did catch is that part there.  Apparently someone had left debox statement in production code.  They fixed it, and it pretty well shows up there.
      The second one I'm running is react.  How many of you here use react?  I don't see any hands up.  It's supposed to be hard framework; right?  It's probably the rates.  It's all the shine and glimmer that I'm not able to see.  But, yeah, I ran it on react.  There was a big, big difference from .5 -- 05 to 08, 01641 is supposed to be coming occupy.  The tests are still running at my home when I left for Cascadia, I'm hoping to go home and see the results.  I'm hoping to see a big increase.  But then apart from that, I also did yet another controversial thing.  I tried to prove that what is good for using icons.  Is it good to use SVG icons or phones for icons?  Bad idea.  Did get a lot of hate mail, but phones are better.  SVG slows down your Web page.  If you need color and animation, you have to use SVG.  But phones are faster.
      And finally I almost have, like, a minute remaining.  So I wanted to leave at telling you guys that this is, like, super simple to do it.  Performance is something that everyone should be doing.  There's a certain standard, and this is something that should be automated.  If you're doing performance, it's super simple.  I was able to show you how it was done in half an hour.  All of this code is open source.  If you're running a framework or if you have a website that you want to run these tests on.  Please come talk to me, and I'll be more than happy to help you guys.  And let's become a performance champion.
      Here are all the lakes, Cascadia and that's my name, Parashuram N.  Thank you, guys.
      [clapping]
      >> Wow.  That was really awesome.  I actually love hearing about your protractor plugin.  I wrote one for accessibility.
      >> Nice.
      >> I love Selenium Web driver.  But it's cool to see the Angular plugins used for other things.
      >> A lot of companies have started using it.  And every time I break something, they come back to me.  But, yeah.
      >> Cool.  Did you find any-like places with the plugin system in Angular is actually really new.  Did you find areas that it could improve that -- like I have some ideas for the accessibility plugin, but I'm curious if you ran into, you know, any issues with that system because it is so new.
      >> That's actually very true.  It is new, and I'm still struggling with this Angular one versus Angular two support, so I'm not really sure.  I don't think I have an answer for that.
      >> Well, I applaud your ability to garner all of that hate mail.
      >> It's fun.  It's fun.
      >> Cool.  That was great.
      [clapping]
      >> So I am in the way of you and lunch.  But I have a pretty important announcement.  If you were at JS conf, you remember the battery and how important that was and not put the battery in your luggage.  This is equally important.  If you're taking a shuttle, you need to go over to the -- there's a registration table outside, and write down your name and plus ones or two, to make sure that you have a spot on the shuttle.  And lunch is sponsored by GoDaddy.  So we'll see you after that.
