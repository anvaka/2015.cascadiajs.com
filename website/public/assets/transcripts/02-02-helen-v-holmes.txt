      >> Thank you, Jan, do you mind coming over here for a few seconds?
      So I was just wondering if you have a favorite data visualization, like, a certain data set that you've worked with was just particularly fun or cool?
      >> That's an interesting question.  I have a slide project that I've been working on, or I worked on for a while and now it's been stale with last FM scrobbling data.
      >> Oh, that's cool.
      >> But my own data so anyone who uses it can put their log in information and use it too.
      >> So you can see when you played stuff.
      >> Yeah.  One of the things I wanted to try to help visualize was when I discover, like, a new artist and then how I get addicted to that for a period of time.
      >> For sure.  When you listen to that one song for an entire day on just repeat.  Got it.  That's awesome.  Thank you so much for share that tonight.
      >> Thank you.
      "JavaScript and Prototypal Inheritance: Why Is It So Complicated?"
      By: Helen V. Holmes.
      >> So our next speaker is Helen Holmes, and she has come to us from the east coast from Virginia, we're getting a little set up.  More filler time.  I only had two anecdotes prepared, so I don't want to use my other one quite yet.  If I can remember what it was even at this point.
      I'm going to bring my phone up next time and take another selfie just to balance the two, and we'll have another one.  That will be super fun.  Anyone have any good jokes?  That's a common question; right?  Yeah.
      So a guy walks into a Halloween party, but he's dressed normal except that he has a woman on his back just riding piggyback and everyone's, like, dude where's your costume?  And he's, like, oh, I'm a snail obviously.  And they're, like, well, who is she?  Oh, that's Michelle.  That's my snail joke.
      You all set?  Almost.
      >> We're getting there.  We're all right.
      >> All right.  Give it up for Helen.
      [clapping]
      >> So this is a photo of my grandfather.  He's showing me what a slide rule is, and he's super excited about it.  If it wasn't already obvious from looking at this picture alone, my grandfather is kind of a nerd.  None of us are nerds here.  He went to MIT for physics, and he's a super, super smart guy, and my grandmother tells a story about him like this.  And they're newlyweds and my grandmother buys a camera and she's excited to take photos.  And my grandfather on the other hand is, like, I'm going to learn everything there is to know about library.  So he goes to the library and checks out a bunch of books and checks out all these on things photography and cameras and the physics of light.  And then he goes and shoots a bunch of rolls of film and then this is -- this is the best part.  He turns his mother-in-law's kitchen into a darkroom on, like, a weekend visit because, you know, you wouldn't want to do it to your own kitchen.  Goodness gracious.
      And then at the end of this he cleans everything up and then just, like, completely dropped drops it.  He moves onto the next thing.  I think the next thing was taking apart the sewing machine that they had gotten as a wedding present, but I'm not sure.
      So my grandmother who finally got her hands on the camera is, like, how do you use the camera, Fred?  I don't understand all the buttons.  And he goes in reply, well, before you start doing photography, you have to understand the history of photography and how light works and how light refracts the camera.  What?
      My grandfather didn't think the camera was scary because that's how he learned.  He got a bunch of books and he would just read all of them and learn about the inner working and the history and the manual and doing all that work was really overwhelming to my grandmother who just wanted enough info to get started.  She just wanted to do it.  She just wanted to know how the buttons worked; right?
      And so I chalked this up to the two of them having two different styles of learning.  And neither is right or wrong.  Different goals, different desires.  So I called them and so trying to level up your skills can feel like this and very overwhelming and frustrating, like, you walk into the ram of the Internet and everyone learns differently.  And I personally relate a little bit more with my grandmother than my grandfather.  So when this happens, it takes very little for me to feel terrified.  I feel terrified all the time doing Web development.  And show of hands for the brave, who else feels this way with me?
      Oh, thank god, I was afraid no one was going to raise their hand.  I thought I was the only one.
      So this I chalk up to the fact that, you know, beginner tutorials are all over the place, but intermediate and advanced aren't.  And this is stressful to exercise your best judgment as for the best course for you, specifically you when programming becomes less about basics and more about opinion and technique.
      So that's the name of this talk; right?  And I consider this the worst sucker of the bunch because you write JavaScript a lot and it's the most can confusing and complicated aspect of the language that we're writing all the time.  And that can make learning it feel your daunting.
      So since we all learn differently, I kind of want to tackle going through this talk in both ways.  Like, for those of you who totally like -- her grandfather sounds like me.  And then for all of you who are, like, no, I just want to, like, learn how to use the buttons and get started.  I want to give you the research to do that too.
      So I also want to help dispel some of the confusions for inheritance, it's history, why does everyone act like it's so complicated, and JavaScript language and also go over some examples so when you're looking at stack overflow later you can understand why people are fighting what they consider the best way to do something.
      So it's 1995.
      [Laughter]
      You like that pose?  So a man named Brandon Ike is working for Netscape and he's making a language, and because it's the '90s, Java is king.
      So at this point it's becoming obvious that, like, the Web was forced to be reckoned with, and the Web was still a baby.  And so it was a marketing move, the name of the language was Mocha script and then it got changed to JavaScript, and then the reason for this were the creators were trying to boost this popularity when the language.  Even making the language look a certain way.  This is some Java, public static void name, I'm sure you guys have written those words before.  So we see semicolons and curly braces and they do this for adoption.  And Brandon even said what you're supposed to do.
      So while this might not sound like a good reason to change your language, I actually want to take a second look at Sass.  And the reason why because other than its initial spike and history, Sass didn't just begin to, like, stealed climb until Sass 3.0, which came out in 2010.  So it's -- and of course for those of you who don't write a ton of Sass, like, SCSS came out a few years ago and it looked like CSS, and all those thought that the Sass variants of Sass, and it looked like Ruby and felt scary, SCSS felt family, and having something feel familiar, even with us rough developer types can drive adoption and interest.
      So the only problem with this move -- sorry, guys.  Oh, my goodness.  I'm so nervous right now.  Look at my talk just dying.  Where's my mouse?  How do I use computers?
      I can do it.
      So the only problem was this, it maybe not us assumptions that JavaScript was wrong, and mainly it works in Java like it does in C++, and it doesn't.
      So and people began learning JavaScript, and they, like, embrace this.  They're, like, I love prototype inheritance, and others didn't and then you throw in the fact that all of us are developers and different skill levels and then prototypal inheritance is super confusing and hard, and others are, like, no, it's easy.  You just don't get it.  That's, like, the, well, actually cat from yet, you know?
      And they're all trying to give code examples applicable for the code we're trying to write for the Web.  And Alex has this great post where he's trying to explain how to write and they're all awful and the most notorious part of this as of the talking animals to describe objects that we give functionality, and it's so ubiquitous that people love to use it as an example.  Here's the tweet.  And on the sixth day, god created an abundance of talking animals that they may use in JavaScript inheritance examples.
      Thanks.  So the only problem that as an example, people actually use this example a lot.  So remember that part where we all raised our hands and said learning things on the Web was hard?  That's the reasons for it.  So what is prototypal inheritance then?  We haven't defined it yet.  So it's important to know that negative JavaScript is a object, and the object have a links together, and the relationships, which is called prototypes, and this is true until you reach null.  That's an object literal.  Conferences are fun.
      So let's look at a code example.  So here we're creating -- oh, goodness.  Someone's tweeting at me.  I hope they're saying something nice.  So the first thing we're doing hear is we're creating an object literal.  Oh, goodness.  Anyway.
      So it's just an object that we haven't attached to anything.  It's just an object, and we're calling it user, and we're giving it a function called tweet.  That's the thing that just happened.  And it takes a string, and if that string is less than 140 characters, it returns the string and the name and the user.  And at this point we have no idea what the user user name is going to be.  And at this point we create Helen V. Holmes and here's we have the object dot user, so here we see Helen V. Holmes is a object and we're filling in that last line, the last piece of in the accident of, which is the this dot user name, which is you saw in the tweet earlier.  So now you set them up so they all have users and prototype, and this is basic object oriented stuff, which is awesome.
      So what's also cool so that you can assign properties all over the chain and we can check for those properties later.  So say I look for a property on the Helen V. Holmes, and the Helen V. Holmes object isn't there, so that's me.car.  Say I look footer property on the Helen V. Holmes project, and it isn't there, to look for this on its prototype, and its prototype prototype, until it finds it and reaches null and gives up and gives you an error.
      So JavaScript is pretty fun because of all these examples, everything is an object.  So this is interesting because any object can spit out nigh objects and become the prototype for a new object.  In fact, every object you ever create can have different methods than all the other objects in the ecosystem.  So this is JavaScript just letting you know what you need to do to describe your world.  Which is cool.  People love JavaScripts.  This is why.  So I have another example for you.  Let's say we have a very specific user that's, like, a regular user and admin, and then a super admin.  He has, like, a Twitter shirt on.  So call him a power user.  And have made a power user because they're allowed to flush the database.  So this person is allowed to delete everything on Twitter.  That's why they're so special.  What an odd power.
      It's, like, the lamest superpower ever.  I can flush databases.  So this will also illustrate another instance for prototypes are really rad, which is multiple inheritance, which we'll be doing through a new ESX feature, which emulates the way we use mixins currently in ES5.  So we're you can't create a power user, and then a property of the first user we created above.  So one more step in our chain.
      I need to scroll.  I'm sorry, guys.  Computers are so hard.  There we go.  Okay.  So I scrolled past, like, the user code because you've already seen it.  So object dot create user.  So you've seen all that stuff.  And we're creating an admin object and he hasn't a couple of things.  He can view the database, also write to the database.  And then for this last thing, you see, like, this power user that we're finally creating.  So for our power user, you'll see that we have the two properties, he has his user name, which is Twitter.  Twitter can flush the database.  And that's set to true.  And then we also have this object dot assign method where we're creating a new object, applying the properties of user and admin to it.  And then assigning the last two properties of user name is Twitter, he can flush the database.  So now we can do stuff like this.  So if we console log power user dot Ken dot database, we get true and that makes sense.  And then if we can view database, we still get true because JavaScript is, like, that's not on user and it goes to the next prototype and then it finds the property there.  And then lastly we can do power user dot tweet and we get that tweet function that we defined earlier at, like, the very beginning I.
      What's really cool about this stuff is the ability to add on functionalities as you go along.  So, say, like, I create my user, like, you've seen this user code, like, five times.  So later I want to add messages and I do user dot message and a message string and user and now code.  And now our user has of a direct message method.  So actually scattering functions all over your code like those doesn't make for clean code.  But it does make useful when you're trying to debug or live reload something.  So say, for example, in the middle of our app our tweet function stops working and we're trying to figure out.  At the point we suspect, we can just override the bug.  So we don't have an app to show, but here I'm just console logging the tweet and just trying to figure out is the tweet string just not defined here for some reason?
      Since objects are first class citizens in JavaScript, it's really easy to implement stuff like this.  This is why some people think JavaScript is awesome, because it is.  Helen V. Holmes JavaScript for every.
      So I've been going around this other paradigm, which is classical programming, which I can't do anymore because I can't understand, and it's why what you just learned is so foreign to all the Java and C++ developers.  So if you remember a history lesson, Brandon Ike created Java, he designed the language to look like other popular languages, and either though it's a prototypal language, he also make JavaScript inheritance look like classical inheritance even though they're different.  So the new key word is an example of that.  So I call this the new debate, even though there's nothing inherently correct in using the new key word.  In fact, one can argue that classical inheritance is just a subset of prototypal inheritance.  So let's look at an example.
      So in this example we can create a constructor, which is basically just a function that, like, spits out objects.  So we're calling this a make user function and we then attach a tweet function to it, the make user dot prototype dot tweet bit.  And then we make me exist, and then we make me tweet, and then I say, hi, Cascadia friends.
      So this is actually a different with a way of doing exactly what we did before, although it does take a little bit more work using the sway.  So we just learn all about how in JavaScript, how objects can be new objects, objects don't have to have the same properties, JavaScript is just really, really malleable.  And this is the way I think about JavaScript is, like, being on vacation.  So, you know, Monday, like, you don't have to do the same thing on Monday that you do on Tuesday and you can eat ice cream for breakfast and for lunch later, which is my kind of vacation.
      Instead of everything being a project, classes need to mimic their classes in any way.  All instances that share and look the same class, look and act the same way.  So this to me is more like your workweek.  You're up at the same time every day.  Is this sad?  Everyone's, like, oh, on work.
      So you're, like, you try to wake up at the same day, try to get out the same day, you work the same hours, and you, like, know where you're going to be vaguely at what times of days.  So if we just carry this analogy along, there's no reason why evacuated regimented vacation, you can keep vacationing wakes up at 7:00 a.m. and keep becoming building out the door at 8:00 and keep works 9:00 to 5:00.  Although it's not a vacation.  But the other way around it's much harder so if you're going to roll into the office at 3:00 p.m. one day and then not at all the next day and then 11:00 a.m. the next day, you would have to worry about keeping your job.
      So classes are an analogy for our workweek example, they have routine that their instances act the same way, we know they're properties at any point and we know what they're going to do doing when.  Prototypes can be all over the place if you work them to be.  Building a class system on top of prototypal inheritance is really easy.
      One method fills out freedom and the other encouraging regime.  So this goes without saying.  But developers get really opinionated on the right way to do something.  So much so that sometimes even our linters will tell us to do something and not explain why.  So this is why someone saying why is my lentor telling me to do something one way and not letting me do the other?  That's why the developer who wrote the lentor was trying to push him into one paradigm over another.
      So my point is lots of smart people think that using classical programming in JavaScript is silly.  But there are also lots of people who think that a classical approach in JavaScript has merit.  So if you've been keeping up with ES6, you probably notice that class is arising as a key word in JavaScript.  So I can't understand arguments here that this just makes everything more confusing because JavaScript is still going to be proto -- like a prototypal language.  But I consider not egregious that ES6 is adding this functionality because it's really just syntax and it's just, you know, still prototypal inheritance under the hood.  So it kind of makes it easy the way to program the way you want to program.  If it wasn't obvious how I feel about this, I think it's kind of neat.  You can find beautiful solutions in lots of different ways.  If you couldn't, we would probably be out of jocks.  Hopefully not anyway.
      So I'm really not here to say that prototype languages are awesome.  Class languages suck.  Do everything the way I tell you to do it, even though we're at a Web conference and I'm a Web developer and I'm up here and supposed to be an expert or something.  Like, anything else it has nuance and depending when you're building, sometimes one of these approaches gets the job better than the other, and it depends on the developers and the resources and the knowledge you have.  And most importantly sometimes one of these approaches is just better for what you're trying to build.  Sometimes you can build a work routine that's really inefficient and confusing.  Sometimes when you're on vacation, you can eat too much ice cream and feel terrible.  So protecting yourself against code that makes you want to corrode is iteration of code reviews and contemplating problems when it makes your head spin.  Not using this paradigm over this fair dime.
      So I said at the beginning of this talk that all of you who wanted to know how to press the buttons on your figurative camera had the resources you need.  So here's the things I find helpful.  This is going to be really obvious.  Developer docs.  So this may seem obvious, but they're clear-cut, no nonsense articles for not only understanding inheritance but everything else about JavaScript and things that are Web related, and I'm a fan.
      The next thing, again, a great deal about prototypal inheritance because they're both in that JQUERY world and they both have books and articles all about it.  The last one is Eric Elliott, who is sort, like, the third part of this piece is super opinionated about prototypal inheritance and functional programming is the right way to do something.  So his stuff is first down read simply because he's so opinionated.
      So back to this guy.  So if you remember at the beginning of the talk we learned about my grandfather and the story of my grandmother always tells about him.  About the camera that they had as newlyweds.  And she always told the story because it was funny.  But I've always gotten something a little bit different out of it.  So you see growing up, it wasn't my grandfather who took all the fathers in the family.  It wasn't him.  He never picked up cameras.  It was always my grandmother.  She had so many photos, she had a room in her house filled with boxes with them.  She went from not knowing how the buttons work to being the family photographer to being the family H historian, and I don't think he she ever picked up a book.  She's just really wanted to tinker, and she just wanted to figure it out, and she did.
      And I said at the beginning of this talk that I'm often overwhelmed and I think that feeling is normal.  And when I'm feeling that way, I think about my grandmother, and I think about how it was she, not my grandfather who end up with that room full of photographs.  Because she knew that if she kept trying, she would eventually click and she had faith she would have fun in the process.
      And I see someone say all the time to her your husband is so smart, and that's probably true but what a lot of people missed is that she was smart too and expertise comes in different shapes in sizes.  So I hope you learned about prototypal inheritance and I hope that it clicked, but also one super confused developer to another, even though we might not get it now be with we will figure out, and to Cascadia and all of you, thank you very much.
      [clapping] 
