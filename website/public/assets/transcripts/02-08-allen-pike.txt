      >> All right.  That was fantastic.  Thank you, Courtney.
      I am just completely thrilled to introduce our next speaker.  You probably know him better as the previous MC for the past two years of CascadiaJS.  Or CascadiaFest as we now know it.  Allen Pike he runs Steamclock software in Vancouver.  Creates mobile apps.  And like I mentioned was the MC for the past two years of Cascadia.  And he was really when I was approached to MC, he was really my role model for his warmth and generosity during the past conference that I attended.  And he was also the first person that I ever heard say JavaScript.  So I would like for you to help me welcome Allen Pike to the stage.
      >> Thanks, Lydia.  That's awesome.
      "A JS Framework on Every Table: Todo Examples All the Way Down."
      By: Allen Pike.  
      >> So today I'm going to talk about frameworks, and if you're familiar with me with them, they're like JavaScript frameworks and a lot of the same systems apply in the two ecosystems.
      And the specific thing I want to dig into about JavaScript frameworks, is why are there so many of them?  What is going on?  What are you guys doing?  This is something I really wanted to understand.  So I dug into it.  This is a journey that happens at the beginning of everything project that I start, and the beginning of every project that most of you start.  Which is, you know, we're looking to build something, specifically in the browser, specifically with JavaScript.  What framework should we use?  And this is normally an exercise of looking out and evaluating the 10 or 0 million frameworks that have been invented since last time you created a JavaScript project.  And figured that there's absolutely no community consensus about which one is the appropriate solution for the problem that you're trying to solve.
      And the JavaScript community, this is kind of considered to just be a normal thing, like, that's just kind of the way it is.  But in if other communities and other programming languages, this is not considered normal, and it's definitely not considered good.  If you're, say, writing swift or Objective-C, you're using cocoa.  You're using Apple's framework that they provide, and it's not perfect, but it's really good.  It's already installed in the operating system, and there it is.  It's what you're going to use.  If you're using Ruby, you're probably looking at rails, there are other specific use cases, but the thing that's driving a lot of Ruby applications is rails, and it gets a lot of development be and e-mail generally how to understand things on rails.
      In the C++ world, it's probably more extremely, you're probably online using C++ because you're using it for some framework and we're using unreal and unreal solves our problem and therefore I'm using C plus.
      The JavaScript world, though.  The JavaScript world has a lot of frameworks.  A lot.  And it's kind of mind-boggling.  And the latest JavaScript framework comes around every 16 minutes.  Which is a lot faster.  I have measured the other ecosystems, but I think it's a lot faster.  This comes from an important scientist.
      But, you know, in our community societies extreme that we do entire projects just dedicated to making the slightly less ridiculous.  The project is actually a important project that's run by smart folks that help people put together examples of JavaScript NV frameworks and what it looks like to build a to-do list application using these front-end JavaScript frameworks.  And there's a few dozen up there and in some other communities it they might think we're weird for using the to-do list.  I mean isn't that a trivial thing to be comparing the possibly most important architectural decision of your entire application by just comparing a to-do list?  But believe it or not a to-do list is the most sophisticated way you can build in a JavaScript framework before a new cooler JavaScript framework comes along.  So it's actually the perfect fit for this.  So they were thinking really well when they made this to do NVC recalling.
      Even though there's dons of frameworks on here, there's many more frameworks that people have created to solve really important totally different problems that they want to do to put on this site and then go through the poll request system.
      And if you go and look, and first looking at this when I was digging into this back in February, and at that time the most recent framework that someone was trying to get added to do NVC, a poll request a day or two prior was this thing called RiotJS.  Which I had never heard of before, when I was writing this article I made fun of the fact that there's even a new one and it's version 2 of RiotJS, and riot JavaScript is a version of 1.0.  And I didn't have any idea of how crazy that was going to be because when I posted that thing making fun of it, I got a whole bunch of e-mails like this.  Thanks for that tip on the RiotJS fortunately.  It's really cool.  I'm going to use it for my next project.  And I don't know.  This really -- weirded me out, and I didn't fully understand how it was possible.  How could it be that in an article -- create this article entirely about how ridiculous it is that there's too many frameworks, and I get a bunch of e-mails saying, hey, thanks.  Cool a new framework.
      The answer is JavaScript.  That's how.  This is something that's not, you know, there's multiple frameworks in multiple languages.  This particular mentality is Euro parcel part of the JavaScript community.  And I think it's important for us to understand a little bit about what causes it, with the hope of maybe minimizing is in the future.  So the defining thing about JavaScript compared to any other programming language is that it's the language of the browser.  And that's, you know.  Let's all be honest, that's what turned us onto JavaScript for the first place for most of us; right?  The browser is the most successful probably distributed application, software platform in history.  It's kind of a big deal.
      And if you want to write something for the browser, which of course you do, virtually every software developer needs to, then you can have your software run on everything from a refrigerator to a wrist watch and everything in between.  And this incredible amazingly powerful thing.  It's so powerful, it will get people from all sorts of backgrounds, technically who were used to all sorts of different things all pulled into the world of JavaScript, and they get sucked into this vortex because, you know, it's not necessarily that they didn't, like, go or PHP or Ruby, but it's that they needed to build things for the Web.  Specifically for the client, the browser.
      And what starts happening is that you get in this community that isn't really self selected; right?  It's not like a whole bunch of people necessarily -- we started writing JavaScript, and we were into it enough that we're now into a JavaScript specific conference.  But people were first getting into it are just getting pulled in because they need to build for things the browser.  And their backgrounds are often technically diverse.  And the frameworks that they were used to are, like, well, they were used to rails or whatever frameworks go and all these various backgrounds.  That educates what they're looking to do and how they're looking to do it in the world of JavaScript.
      So this creates a whole bunch of diversity and sort of frameworks that people are creating and people are looking for.
      At the same time we have this big diversity of how people are trying to do things.  We have an even broader diversity of what people are trying to do.  And now, the Web was originally created to display static Web pages.  And a lot of people ran JavaScript to do.  And a lot of it now is also creating Web applications, rich productivity applications that have requirements and situations that they're having in, some are consumer, some are business, all the way down to people doing 3D graphics on the Web, which is completely crazy, or at least we would have said is completely crazy a couple of years ago, now it's people are doing for really serious projects.
      And now we have this incredible diversity of people from technical backgrounds of how they're trying to do things, and also an incredible diversity of what people are trying to do in this language.  Which is really something remarkable.  There's very little that you can compare it to that has such a diversity of inputs and outputs.  And this generates a huge quantity of people who are trying to build their own frameworks, and huge quantity of frameworks that people may be looking for.
      At the same time we have this huge diversity of things -- this huge unimaginably large amount of work that we may be trying to do on the Web.  We also have this very low base layer that the browser gives us for free.  Specifically the language of JavaScript.
      For example, the standard library in JavaScript consists of shitty data library and an empty can of tuna.  That's all you get.  And it hasn't stopped us.  The Web has completely revolutionized the entire world; right?  But the way it has done that was building all these layers on top of this.  You might think this is making people in the Web community pessimistic, but it makes them optimistic and excited about the things they can do on this platform.  Because they're doing very little and their goal is to accomplish incredible things.  And that is a good thing for a lot of reasons.  But one of the consequences is this.
      Which is the number of active repositories in GitHub and it's going off the edge of the graph in the corner there.  And this is 350,000 repos, and I'm sure about 90 to 95 percent of those are JavaScript frameworks.  So I'm not sure exactly if it will ever stop.  But it's like people are doing this because they're bored.  There's a incredible number of wide diversity things that people are trying to do, so it's generating a lot of work on the framework side.
      In the meantime, though, just because people are trying to do a lot of things, it's not, like, we will settle on all the frameworks we need.  There's another force in addition to all the frameworks being created, also killing frameworks.  And that is also the browser.
      And what's happening with the browser is that it's moving incredible ridiculously fast.  The browser is out dating frameworks far faster than on any platform that you would ever build a framework on.  Compare to, say, when we talk about rails; right?  Rails has been around for many years now, and it was built on Ruby 1.6 or something and now it's up to Ruby 2.2.  But the difference in between the platforms that that framework was built on was really minimal.  There's not much difference in between those.  So rails adapts to the foundation, buts there not a lot of change there.  Compare to the browser, when there's been more changes in the browser the last six weeks than Ruby in that amount of time, maybe that's an exaggeration, but what's happening is you have this cool framework that's good add working around how the DOM is so slow.  And then you have this framework built around the foundation of the browser and then they make the DOM not slow anymore, and then you have this framework that doesn't necessarily make since anymore because its built on something that's shifted.
      And this is a common problem.  This happens to frameworks all the time.  We're legacy design decisions because this is the way that IE6 handled things and you couldn't do things certain ways.  And IE6 feels like a long time ago, but it wasn't really that long time ago when we talk about creating a big system debugged and shipped.
      The other way that browser kills frameworks and under mines frameworks is the simple fact is that he have single time someone wants to use the application, then the browser downloads and parses the code in your application.  That's the point.  That's what we want it had to do.  But the fact that that's what's going on when someone loads your client side Web application, means that all the code that's in your application that you're not making use of is now a liability.  It's a performance concern.  It's something you worry about; right?  It's something that's potentially causing issues on some edge case that you're not familiar with.  So this creates a sort of strong downward pressure on the maximum happy size of the JavaScript framework.  That's not the case in other frameworks.  And this is problematic for someone who is trying to create the final JavaScript framework that solves he be everyone's problems for everything.  Because the natural progress of a framework once it does a little bit is to start doing more.  And it starts to do neighborhoods thing relevant things.  Once you solve this problem, people are, like, well, I have a similar problem.
      And in most worlds, that's a good thing and generally what people from other platforms, maybe app deformity or something are often looking for.
      In 2008 I spent a couple of years actually building a software, which was one of these frameworks that was in this vanguard of finally a JavaScript framework that will end all JavaScript frameworks, and all the libraries we need, it's going to have all the various functionality from someone we expect like cocoa on the Mac, and we're going to build in the browser.  And it was almost ready, it just needed a little bit of polish and documentation, and it was going to be great.  So this was in 2008, and there's a lot of optimism at that time.  We were getting demos of things, like, cappuccino, GWG, and things like that.  And we were building this app, it was, like, productivity app and we're, like, we're going to build this on the Web, and it's going to be amazing.  And it was okay.  It was pretty good.  On the desktop.  Once we worked through the various performance problems that we had.  And then mobile happened.  And that was kind of a problem.  Because we had multiple megabytes of JavaScript.  And when I was given an iPad and said it needed to work on this, it crashed as soon as it lotto loaded because it would blow the 256 megabytes of memory on the iPad.  And that was really sad because I had really bought into this idea that Morris law was going to solve the frameworks and we were going to make a framework that would solve all of our problems and a bunch of really smart people just give you a toolkit to be able to build software.
      And more and more, especially after this kind of downfall of this particular framework that I had fallen in love with, or at least gotten good at.  I feel like this has made an evolutionary dead end.  And this thing that seemed reasonable was actually kind of dumb.
      And when you looked at it, it's, like, no, this seems.  Yeah, that could be a thing, but it doesn't make sense to be a thing.  And that's kind of sad because I sort of wanted it to be a thing because it's kind of awesome and weird.  But what I've seen in the years since, it was almost ten years ago now, is that what happens instead in the client world, in the browser framework world, is that small nimble frameworks tend to out compete the large growing frameworks.  And in some degree this is because of the performance problems of the more code you'll have, you'll have someone else's code that solves other problems you don't need, then that causes problems for your framework that you're using of, and so you have this kind of shattering behavior.  But there's also another effect that's kind of the small nimble more libraries than frameworks is kind of natural to the way that JavaScript likes to be written.  It's a quirky, dynamic, loose language that, you know, it's not typed, you know?  And you can have API's like this.  What does do?  I don't know.  But it was really quick to write.  And in a small little library as long as the person using it is the person who wrote it or understands it pretty well or this is the one of the core functions of it, it successfully loads whatever that loads.  And that's okay.  You don't need a ID that can tab complete and tell you what all those parameters mean and making sure a compile team is passing through and it needs to be something different.
      Of course for a large application when you get up to the size of a operating system, it starts to become really problematic.  Not the fact that you can write an API like this, but the fact that if someone else does, there's no way, typing time to know what's going on with this.  And companies like Google and Microsoft that are used to dealing with code bases are getting more and more interested into how do we give it a bit more compiler sense for types and things like that into JavaScript?
      And to some degree that will probably make it more and easier to maintain large frameworks as well as to actually build on, maybe more importantly to build on large frameworks that had been built in these languages.  But it's definitely a fair amount of unrest in the community that this takes away some of the fun of JavaScript.
      So instead the general sort of consensus along the people who know what they're talking about, TM, is to build things with microframeworks instead; right?  We compose everything out of lots of little small things, which they call microframeworks, I think they're libraries, I don't know why we're calling them that, but apparently they're microframeworks, and you compose your application out of all these puzzle pieces.  And this is a great approach when you have smart people who understand the ecosystem and the tools that are available to them, and they understand the problem that they're trying to solve.  So you can go out and you have female People who often have themselves written their own frameworks or at least libraries and things like that so they can go and download these frameworks and read this source and figure out whether or not they're a good idea and compose this into a project for themselves.
      Unfortunately, for a team that's maybe not super strong yet at JavaScript development or the team that doesn't focus on the client or a team that's a mix of junior developers and some senior develops is that it ends up being more of jumping a whole bunch of puzzle boxes into a pile and pillow of pieces together.  It doesn't give them a sense of this is how you should build JavaScript apps in this -- within this set of tools.  It's just, like, yeah, well, defend for yourself, guys.  And that's not a solution for a large company for a large project.
      So instead a CTO that's told pick a JavaScript framework.  So they do this.  Your little JavaScript frameworks.  Of course that returns results that are all from, like, 2014 and are completely useless now.  So they do this.
      [Laughter]
      And I know they do this because then now what they get is the article I wrote in February 2015 saying that there's too many frameworks and they're screwed.  And then they write me e-mails about RiotJS.
      So is this bad behavior?  No, this is people trying to solve a problem that need to have a coherent teachable readable set of documentation for their team about how are they going to try to solve the problems they have on one particular project?
      People don't want to spend their entire time fishing out that boron JS is going to solve this problem that they have.  What they want to do is jump onboard with something and get where they're going; right?  And, unfortunately, what this causes is whether they start with microframeworks or some homegrown thing, use vanilla JS, it means basically what they do is end up creating a framework.  And once they've built their own framework and they can't hire anyone because no one else knows the framework, they have a good idea.  What we're going to do is release our own framework into the world.  And once we've done that, we will solve global warming once and for all.
      Once and for all.  So now we're back where we started.  So I think we have a -- at least a much better understanding of why we have so many frameworks and why there's this continual turn.  But before I finish, I want to touch on four ideas of maybe what we can do about it when we're in this situation, in this community and how can we deal with it?
      Well, option number one is that we can actually start to enshrine some of the frameworks we have into the browser.  And this is a slow process, and it means you have to get all of them to agree, yeah, we should have this framework or even entire framework built into the browser.  So this is a hard problem.  But there are some examples of this actually working.  You'll get, like, Query select or all, and in 2016 when all the -- all the frameworks are doing the same thing now.  When that stuff kind of happens, you end up reducing the amount of complexity that the framework needs to have and the amount of thrash because it's, like, well, we could replicate this.  But the way the browser does it is pretty good, so let's just go with that.
      Option number two is we can get really low level.  We can go right down to the level of some of these new frameworks -- not frameworks, new API's that are coming out, like, WebGL, now the Web assemble stuff that's coming down the pipeline hopeful, to be able to build on a stable bottom layer.  That's not going to change anymore.
      And once you start doing that, then what happens is that it's a standard platform that's not changing anymore, and so you can build up substantially larger amounts of complexity, and you can work around problems like not having certain features in JavaScript and things like that.  Maybe we're not even using JavaScript anymore.  So, again, this is a relatively long term solution, but it could be a fairly permanent one if we get to the point that Web assembly and WebGL are fully supported and they're on all the platforms that we want them to be on.
      Option number three is a little bit more feasible in the short-term, and it's kind of what a lot of people are doing, which is this incremental breakage idea.  We create a framework and even had to it is popular, we resist the urge to continue down that path because in the Web world we're always finding new better ways to create software and we get to the decision, yeah, I know a lot of you liked our bicycle, and now we're making a car, and if you want a car, you're going to have to come with us.
      And this is what angler is doing, and including me, building the most hyped framework of all time, and then angler two being angler one stuff isn't going to work anymore.  That's old and busted.  And the fact that they're willing to do that, it's daring, risks all the momentum they have with angler one.  But it's a different kind of risk than a slowly sliding into oblivion and then eventually just sucked themselves out of life.
      So this incremental breakage thing might be the least bad.
      Option number four, though, is to embrace the chaos; right?  This is the Web.  It's always been chaotic.  Maybe it always will be.  Maybe, just maybe, that's what makes it great.  Thanks.
      [clapping] 
