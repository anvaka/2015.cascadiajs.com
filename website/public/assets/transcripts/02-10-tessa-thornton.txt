      >> When I get on stage, you don't see it from the floor, but these lights here are extremely bright.  And I keep thinking of that Star Trek episode of the guy tries to torture him and there are five lights and he's, like, there are four lights.  And there are actually four lights -- I don't know.  I don't know I didn't keep thinking about it.  But there are four lights.  Yeah.
      So let's kick off our last talks of the day.  It's been a really big day full of a lot of great information, and we're going to go out on a really strong closing note.  So I am super excited to introduce Tessa Thornton, and she has visiting us from Toronto.  So please give us a warm welcome to Tessa.
      "Components are the future of the web: it's going to be okay."
      By: Tessa Thornton.
      >> Hello.  All right.  So here to talk today about components and the future of the Web.  And so I'm from Toronto at Shopify, and that's where you can find me on Twitter if you get mad about something.  So talk about building apps with JavaScript, which is something I think a lot of us do.  So I'm going to start off with a bit of a history by the, so maybe an accurate history of Web apps or what we call Web apps.  So the in early days of HTML and the Web when we were just starting to realize that we could do things more than just display read only information.  We were using all -- all activity was coming from forms and links.  So you have stuff like this.
      So forms and links are pretty good at doing forme and linky things.  So this is pretty okay.  Actually if you're looking at it and especially if you're coming from, like, before the Web -- well, not before, but the Web didn't do much else than this, and this is the only way to collect information and send it off to the server.  It's not a bad way to do.  It you can read the code and tell what's going to happen.  You can see what HTTP method is being called, where it's being sent.  Pretty straight forward.  So that was cool for a while.
      And then JavaScript grew up.  It started becoming useful.  AJAX became a thing.  So now we could communicate with our servers and have interfaces that are just forms and links doing forms and linky things.
      So we have the same form and collecting data and sending it to our HPH file to be loading.  So that's how you got this thing, calls a global function in our JavaScript file.  We decided that that was really bad.  We thought that along with inline styles, which we also decided not to do, inline event handlers were a bad idea because our markup is, like, this precious thing that we shouldn't contaminate with things, like, JavaScript.
      So we had this whole separate concerns idea because conditions is generally knowledge to be a thing that you want in programming.  So we decided that this is the way we're going to separate our concerns.  HTML for content, JavaScript for behavior, CSS for presentation.  And that was just sort of, like, the rules, like, this slide is probably in a million, like, intro to Web development slides.  I know it's in my intro to Web development slides when I teach.
      So we decided to instead of have that inline event handler, we move all of that behavior out of the HTML, into JavaScript, which became JQUERY, and we decided this is what the best practice looks like.  Keeping all of your behavior and business logic in a JavaScript file that was queering the DOM and listening for events.  So we called this best practices.
      So there is a couple years ago if you follow the CSS world at all, Nicole did a talk about how our best practices in CSS were killing us.  About how we had this, like, ideal of the semantic Web and this perfect HTML that wasn't cluttered with classes or anything presentation based.  That was just really hurting us and making our websites hard to maintain.  So people started to get onboard with that, and now we have other ways of dealing with CSS and our markup.  So approaches is, like, object in CSS and, like, a bunch of other acronyms.  So we decided that was okay.  We got over it.
      So I sort of thank we kind of got there again.  Sort of similar problem happened with JavaScript.  So JavaScript Web applications have become a lot more complex and interactive in the past, like, years and just sort of maintaining that strict separation between our HTML and our JavaScript is, like, not really feasible in a lot of these situations.  So I'm just going to sort of look at the assumptions behind those supposed best practices and why I think they're not right.
      So I don't think the HTML is really just for content.  So this is something I've seen recently.  So you end up with a lot of these place holder things in your markup.  So this is, like, a select element but without the JavaScript, it's not at all interests.  There's no content there.  It's just an empty select.  But then once you add the JavaScript, you're pulling the content in from a JSON file or from some sort of external service.  So I think it's hard to argue that in this case our HTML represents content.
      You then end up with things like your HTML five input type.  So this is a range slider.  So it looks like you've got a lot of, like, logic and behavior in there and there's no, like, content as you would generally expect it to be.  You know, we've got basically we've got business logic in there.  Minimum values, maximum values, a default value, all sorts of.  Stuff that you would generally consider to be in the range of JavaScript or, like, behavior.
      So I think HTML isn't just for content, and it never really was.  I think it was a false dichotomy that sprouted up there.  HTML has these, like, declarative APIs, these, like, nice elements that, you know, pretty easy to configure with just markup that keep all the -- where you actually have things like logic and behavior in your markup, and we always thought that was okay.  I mean we think we did.
      So mention declarative APIs.  So maybe take a second to talk about what those are.  Why we want them, and why they're good in HTML.  So declarative versus imperative programming.  Imperative specifies the steps you want to take to achieve the desired result.  Declarative is saying what the result you want is, and then you leave the implementation up to something else.  So depending on the language or framework you're writing with, the implementation would either be elsewhere, like, other code that you wrote.  Or it's leave the implementation to the filer or framework over.  So the idea is you're abstracting away the process and focusing how you want it, not how it's done.  Because that's, like, a solve problem.  So the standard example given for declarative versus imperative, I don't know if you can see that.  But it's just, like, adding up the values in array.  So the imperative way to do that would be your standard four loop where you're creating a variable that starts at zero and adding each time.  A better way would be an array reduced method.  So it's more declarative in that you're saying what the output you want is, which is that you want to reduce that array to a single value, and you're leaving the implementation of, you know, creating your variable and dressing each time going through the loop, you're leaving that detail up to just the basic array prototype methods.
      So there aren't, like, a lot of declarative languages that you encounter every day.  But most popular one is probably SQL.  So this is, like, a standard SQL query.  So you're selecting student from a stable.  So what's going on under the hood here is that it's actually analyzing your query and selecting the best algorithm to define it most efficiently.  But I don't have to know which algorithm it's picking, I don't even have to know what a search algorithm is because those are solved problems and that's not what you care about when you want to find user number five.
      So it let us you tokes on your own application, your own business application, and not the low level problems that have already been solved.
      So HTML has declarative APIs, so this range slider is a good example of that.  So when you put this code in your HTML file.  You end up with this, like, magical thing that has all sorts of things going on under the hood.  So to actually implement this, what you would have to do if, like, you were building it from scratch, you would have to add event listeners, data binding, there's isn't styling you would have to worry about keyboard access accessibility.  And all these elements that make up what you expect when you have of a range slider.  But as a developer that uses the input tag that it need to get the output of the range slider, you don't need to know about any of that.  All you need to know is that it accepts certain inputs and gives you a certain output.  So declarative code is hiding the details when you just need an interface.  Societies a contract development, the contract inputs and outputs.
      So when -- that's super tiny.  But when we read our own UI code, we don't really learn from this example, we didn't abstract what HTML was already doing.  I think we sort of didn't recognize the declarative HTML because you just see it as the way things are, and we don't think of all the implementation detail that's under the hood.  That can get pretty involved.
      So this is example of random custom UI JavaScript jQUERY code, it was something that I Googled.
      >> JQUERY tabs, and it's adding and removing classes and setting states.  So you've got this very specific HTML structure has to be a certain way, and the JavaScript code depends on that structure being exactly this way.  And so understanding this code relies on knowledge of having basically three different code bases, three different sections of your code.  You need to know what the HTML is doing, the jQUERY, you also need to know what's going on in the CSS because some of that logic is in there.  So you could wrap this up in, like, a jQUERY library, but it would also depend on we're specific markup in a certain way, and it's very not meaningful to read that markup.
      So if we look at, like, some of the HTML there, it's not very meaningful to us, like, what is that even?  It's just a link that may or might not do anything.  We can't tell where that class current is important.  We can, like, guess, but that's just, you know, coincidental.  It's not actually, like, meaningful.
      We ended up having to did you hear relevant dump a bunch of information from the DOM into our JavaScript files.  So this is code that I may or may not have written.  This is pretty much production code.  And so it's kind of shitty that our JavaScript has to care a lot about these classes.  JavaScript has enough problems with classes.  So it's just, like, why would your JavaScript need to know about your weird naming convention that you use for your CSS?
      And then if you look at the by the of JavaScript that -- well, this is slightly different example.  But same idea.  So just a standard by the of JavaScript that's an event listener on DOM element.  So what does that actual QUERY, jQUERY actually do?  So you're going into that big DOM mess that you just created to find this element that we just added.  So we're going to go and look for it, even though with we already know where it is because we're the ones that put it there.
      So writing JavaScript like we don't have any control over HTML.  Which I guess sometimes is the case, but usually it's not.
      So we sort of had this idea that our HTML should be dumb and just sort of, like, this static pristine thing, but we do all this weird shit in our files and we end up with this code where your JavaScript relies on your HTML being done in a specific way.  And if you make it dumb in a different way, it's going to be useless.  So it's hard to read and maintain, is and you've got implementation details all over the place.
      So if we thank maybe some declarative attributes in our HTML are good, and maybe we should add more of them.  What happens when we do that?  So in 2019, angular was introduced to the world at large.  And people were kind of mad about it.  I know -- if you saw Alan's talk yesterday, he used this slide also.  Unintentionally.  So this is the example from the Angular JS home page and the example of how to use Angular.  And the HTML part of Angular made a lot of people pretty angry.  So this is sort of, like, some stuff some people would have said about it.  It's ugly.  Breaking separation of concerns it's, like, a step backwards to the days of XML.  And so I'm just going to address some of these concerns because I think they can all sort of be overcome.
      So separation of concerns.  So like I said the separation doesn't really hollow.  So we have declared attributes in HTML type already.  Or even before HTML five, like, the action on a form tag, et cetera.  Your content isn't always in your HTML anyways.  Like, if you're building a JavaScript weapon app or even a nonJavaScript we know app, you don't have access to your content.  It's in a database somewhere.
      So the sort of nature of the Web is that we need to glue our HTML to our JavaScript somewhere.  You can't just hope it all works.  So you can just as easily say that you're polluting my JavaScript with all that DOM crap and maybe that's just as bad with polluting all that HTML with JS.  And you can sort it by file type, I don't know if that's the best way to go about it, it just seems easy.
      So like anything in programming, not just front-end, there's more than one way to separate concerns, and we need to reevaluate that file type division.
      So inline handlers also made people angry.  But they're not globals anymore.  They're very specifically scoped in the Angular example.  And they're declarative specified somewhere else in the HTML.  In library of event handlers, like, I think a lot of people didn't even hate them at the time.  Some people really liked them because it's easier to read about.  You end up having a lot less code, you don't have to do DOM queering and event listening, which is a pain, and I would argue that they're not the biggest mistake I made back then.
      And then I didn't actually as we understand to have only Futurama and Simpsons references in here, it's just what happens.  The other argument is it just looks bad.  I don't really get the point of this HTML purity thing.  We had this weird purity obsession about our HTML that doesn't really fall into other file types.
      And I feel like we went through this all with CSS too, we didn't put classes in our HTML and we went backwards on that and we're doing that again.  I thought we were going to be a little bit more pragmatically about those things.  So just I think we need to be going forwards on these things.
      So if we're going to be okay with that, and I hope I've convinced you that we can be, we're going to keep going in that direction.  So if declarative attributes are good, then it would be cool if you could make your own.  If declarative elements were cool, it would be cool if you could make your own.  What if you yourself could make something as useful like select or an input?
      So as you probably heard of, there's this thing called Web components.  So Web components is sort of like a cache WC is a set of browser spectates that lets you customize your tricks.  So Web component specs when used together lets you use your own customizable elements with your own styles.  So you can create your own tag, do all sorts of fancy shit.
      So this is sort of, like, an example with the tags example with the tiny for not that I showed earlier.  So this would be a better way.  So when I Googled simple JavaScript tabs, I was given this, and that would be a lot easier to integrate into that Web app.  It's declarative, it's reusable.  I compose it with other elements.  So this is just sort of like a basic example of how you create a custom element.  According to the spec as it was when I first wrote these slides, which was a couple months ago, so might be changed.  But the point is that the implementation details are all behind in your, like, creative call back and you can add event listeners and behaviors and API and all sorts of things that you wouldn't have to see if you were using the HTML element.
      So another cool about things components is that they're composable.  So here these two elements could come from two different sources.  I could you have found one of them on, like, Google material design.  I could find one of them I wrote myself, and have you just to know what properties they accept and publish, and we can wire them together really easily.
      So if you want to use Web components because, like, there are a lot of advantages to them, it's a little bit complicated.  Support is not great, and it's kind of all over the place, and no one can really agree as this is the nature with defining new browser specs, especially big complicated ones like Web components.  So I don't think there's any browser that currently has the entire spec implemented, and some browsers say they're not going to do some of it, which is your standard bummer situation with browser specs.  But there are some options.
      So Polymer is a set of polyfills and syntax sugar and some default custom elements and what they call Prolyfills, which, like, polyfills for things that aren't tech but will be probably be implemented.  It's a lot better than some of the other APIs.  And the idea is you can use Web components right now, and it gives you a bit more of an abstraction layer on top of the Web components.
      So this is what it would be using the tabs element that you get from googols, like, material design library.  It's just, like, a nice, easy to read declarative components.  But if you're not into the whole Polymer idea and some people think it's too soon or they're not totally sold on it.  So the whole philosophy of components and more abstract level is spread to, like, all the frameworks pretty much.  So you can use them no matter where you are.  So Angular has directives.  So they let you create new HTML elements.  But it doesn't leverage the new APIs yet.  So the implementation would look pretty much the same it does in the spec.  And you get things like scope management and usability and reusability.  And Web 2.0 is supposed to support out of the box.  I'm sure what that's going to look like.  But we'll see.
      And similar idea they're trying to add here closely to the specks so that one, components are wild available you can swap them in for your ember components.  They look a little bit different because they use curly braces instead of angle brackets, but it's essentially the same exact thing in syntax.  And 2.0 is going to make components aspect of the framework that it's going to be abstraction refute framework is going to be components.  You're not going to have controllers.  You're going to connecting everything using components pretty much.
      Angle bracket syntax is coming to ember possibly this week.  I don't -- didn't check that today.  But this week.  And then everyone's new favorite react.  React is literally just components all the way down.  It's a central, like, concept of react is reusable declarative components.  They're a bit different than the components in Angular or spec because they're not aiming to be interoperable with weapon components or replace them.  Because Web components are all about leveraging native DOM APIs, but react to the idea that they have a better solution, which is not the DOM.  Virtual DOM instead.  Which I think is a better idea.
      And the abstraction is almost exactly the same.  So you've got your declarative API configurable with -- not HTML but JSX, which is the same idea, and the focus is the same.  Reusable, composable components.
      So prediction for the future, so instead of, like, going back and forth between your very specific markup that, like, you know, is pristine and nice but, like, deceivingly complicated and your JavaScript that's full of DOM queering and event listeners, you're going to go back and forth between wiring together all the components that you've either made or imported from elsewhere and then maybe you'll be tweaking the implementations or, like, wiring -- adding implementation details under the hood.
      So there are, like, limits to declarative programming.  If it was -- if declarative programming was perfect solution, we still wouldn't be writing with non-declarative languages, like most of us do.  Sometimes you need to tweak those implementations.  Sometimes you do know better.  So an example would be -- so in SQL, a lot of the times you can count on the right algorithm being used in the most efficient being used.  But sometimes you have to tune that performance, and you have to, like, instruct SQL how to perform the query the most efficient way because you do know better.
      But usually you don't.  Usually you can just let it do its thing.  And sort of, like, I think the benefits outweigh the drawbacks there.
      So summary.  Almost perfectly on time here.  Sort of, like, declarative renaissance with the Web.  It's coming whether you like it or not.  So evidence of that is that Angular is doing it, react is doing it.  Browsers are all doing it, and if everyone else is doing it, you should too.  I wouldn't normally make that argument, but it's the Web.  You kind of can't fight it.  But I think you're going to like it because declarative APIs are nice, meaningful HPL is nice, and scope is always a problem in front-end.  And even style encapsulation with the native spec.  Reusability and composability, which are big wins, and you can choose your components here.  Components in your own framework, you can try it in Polymer, you can wait and use the native spec eventually.  So I think you're going to pollute your HTML with JavaScript, and I think you're going to like it.
      [clapping] 
