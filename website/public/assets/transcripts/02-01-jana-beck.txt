      Hello, CascadiaFest! The livestream captions can be followed on your handheld devices at 2015.cascadiajs.com/captions.
      [Captions provided by @chaselfrazier @whitecoatcapxg. Thanks to our sponsor @mobify!]
      >> Check.  Good morning, everybody.  This is a -- if you've been to a past CascadiaJS, I usually spoil my kids by bringing them on stage at the end of the event.  Just before we do the big family photo.  Sadly for me, neither me nor my family are actually going to be here at the close of the conference on Friday.  It's kind of, like, super ironic that someone organizing the conference picked dates that didn't work for him.  But, you know, you just sort of learn to -- this was the date that worked for all the other organizers.  So I just took a bullet on this one.
      We have a quick, quick message from my daughter Katherine.
      >> Please turn off your Wi-Fi hot spots.
      [cheering and applause]
      >> Yeah, so, you know, the -- we pride ourselves on having as rock solid Wi-Fi as anyone can expect for a conference.  And we know that we weren't quite there yesterday.  But there's a couple of things we can do to fix it.  The most important thing is there's a new Wi-Fi SID, it's CascadiaFest Wi-Fi.  Please connect to that and only connect to that.  If you are running a Wi-Fi hot spot, please turn it off.  If you have any bandwidth hungry application running, like, drop box, please turn them off.  And also most importantly, if you have any problems connecting to the Internet, if you're running pings and packets are getting dropped, I would like you to immediately find a organizer and let me know.
      Sean from step house -- Sean, can you raise your hand.  Sean is here to help us.  And the easiest and best way for him to help us is to actually have someone's laptop so we can debug what's going on.  So please look for me or look for Sean, and we'll get it sorted out.  We're all programmers, and we're Web developers, so we need the Web; right?
      Cool so that's a little PSA about Wi-Fi.  I am really, really excited to introduce many of you to the curator for browser date.  Katie is one of those amazing people that I have sort of known for the last few years but in a really weird way.  She's been a pervasive preference in the Seattle node community.  She'd been to every meet up, she's been on Twitter all the time, last year show introduced this NodeBots workshop.  But I didn't know her super personally.  I just knew of this amazing person who appeared to have boundless energy and was just always involved in everything that was happening in the Seattle JavaScript community.
      But in the past six months, I've gotten to know her much, much better.  She's such an amazing person, and she is very, very responsible for the amazing talks that you are all going to experience today.  So I'm going to go ahead and hand it over to Katie.  Big round of applause, please.
      [clapping]
      >> Thank you.  Hi, all.  I have some hastily scribbled notes I'm going to subject you to for a couple of minutes.  So welcome to day two of CascadiaFest, this has browser JavaScript day, and I'm excited for all of the talks we have for you today.  It's going to be great.  As you can see I'm modeling today's shirts in bright green.  So if you want to know who's doing things for you, if you're tired and have a question, ask a volunteer, and we'll totally help you out.
      This is going to be a reminder for many of you, but for some of you this is your first.  Event, so at Cascadia we do not tolerate harassment from any attendees, staff, vendors, or responsers.  If you need help or if you feel uncomfortable, let a volunteer know, and we will fix things.  Oh, this is good news.  If the coffee out front isn't to your liking, then Carter has sourced the fanciest of Seattle coffees for you.  Togo coffee will make lovely lattes and poorovers for you and they're right around the corner from rejection.  You can probably hear them if you just walk outside the building -- not the building, the room.  Yes, the room.  Okay.  Good.
      We -- oh, also we're asking you to respect the focus on our speakers at today's conference by maintaining the feared style seating that we have and only using laptops stand in the back of the room.  I have to turn the page.
      The last thing I want to do is ask you to give a huge round of applause to Lydia, she's your MC for today, and those of you who attended the JavaScript here last year, may remember she was also a speaker then.  So this is Lydia, your MC today.
      [cheering and applause]
      >> Thank you.  Hello, Cascadia.  How is everyone today?  Good?  Excellent.  Oh, man, I am so excited to be here.  Thank you, Katie for inviting me to MC and for that warm welcome.  So as Katie mentioned, I was a speaker at last year's Cascadia, but it was also my first time speaking.  So I think I really -- and the amount of first time speakers we've had here today -- or yesterday and throughout the conference, I think really shows how welcoming and encouraging and awesome of an event CascadiaFest really is.  If it's your first time here, please come up and say, hi, to me, maybe not while I'm on stage, but later today just come find me, and I would love to say hello.  And if it's not your first time, I would love to say hello as well.  I have craigslist stickers today.
      And thank you to Groupon who are sponsoring our speakers, they made it possible for all 12 of our speakers to get here today and delivery some amazing talks.  So, yeah, I just want to thank them a lot.  And we are getting set up for you.
      So this is where I kill time I guess.  That's my job.  Let's see.  So I remember last year when I got up on stage at Cascadia, I was extremely nervous, but I also thought that I would have a little fun and take a selfie when I got on stage with the crowd in the back.  So I quick took a selfie like that and thought that I looked really serious and, like, I had my game face on and, yeah.  And then I looked back at the selfie later, and I just look terrified.  I look like I was about to throw up.
      I did not throw up, and I felt pretty confident once I got started, but it kind of cracked me up to look later and I was, like, yeah, I was a little nervous.  So anyway that's my antidote.  So I would like to introduce to you, Jana Beck, she's an engineering at tied pool and is going to talk to you about data viz on the Web.
      >> Good morning, everyone, so I'm just going to start right after the bat here.
      "Power Tools for Powerful Visualization."
      By: Jana Beck. 
      >> Interactive visualization on the Web is a big area, it's a super exciting and collaborative community so if you're interested in it, like, get, you know, get involved because the community is really great.  But that's not to say working in this area is rainbows and sparkles 100 percent of the time.  When you're building it on top of a large real world data set, there can be a lot of challenges.
      So what I'm going to talk to you today about is sort of all the things that I wish somebody had told me before I embarked on the project of writing a large data visualization library.  And so this is basically the tool set that I've gathered for myself over the last couple of years of work, and I hope it will be useful to you.
      So we're going to talk about the most widely used data visualization set, and it's data driven documents, and the SVG driven format.  So you use D3 do build things in SVG commonly.  If you're not familiar with SVG, it's a vector image format that's XML based, so that means all the components of the visualization are XML elements that sit in the DOM just like HTML elements.  And most properties can be styled through CSS style sheets, although not all of them can be.  And just to give you a little over view of where we're going.  So I'm just going to give you a little bit of an example of the SVG basics that's the best practice, in my opinion, and then that's going to lead us into a discussion of performance problems, especially with SVG, and we're going to talk about how to profile those.
      And then I'm going to follow up with just a few tips for how to solve performance problems and that will be a few general strategies and a couple JavaScript libraries that are good tools for working with large data sets in particular.
      So I say that D3 plus SVG is the most commonly tool set.  Why is that inspect it's because what D3 does is bind data, so you've got these it is little miniature JSON objects that I created.  Two elements in the DOM, so those are commonly elements like this circle element.
      So you can use D3 with something like canvas, but, in my opinion, that should be sort of the option of last resort because you're actually losing a lot of this power of D3 if you use canvas.  Because canvas is a raster image format, and the only element you end up in the DOM is the canvas itself, so you're losing this whole power of binding data to DOM elements and basically all the functionality in D3 is around manipulating those binding in various ways.
      So once you've learned those interfaces in D3 and it's basically around three sections that you'll hear about the enter update and selections and programming around those selections.  Once you've learned that core functionality, there's not much to learn with D3.  D3 provides a lot of useful functionality for manipulating data, but in a lot of ways, it's actually a really elegant concise project.  And there just isn't a whole lot more there.
      The real challenge in my experience is that if you really want to become proficient at data visualization, you have to become proficient at SVG.  You have to really understand SVG.
      So the thing that I want to talk a little bit about that's really important with SVG is using group elements.  So this is an element in SVG that's pretty much parallel to a DIV in HTML except for the difference that you can get away with not using it.  I think it would be pretty strange if you had a lot of HTML that had zero D IVs.  But there's basically three good reasons to use this group element, and that's organization, just organizing your code, providing hooks for interaction, and then also it has performance implications if you don't use them.
      So this is probably pretty tiny but all you really need to see here is that what we've got is a SVG with a totally flat structure.  You know, we're just dumping stuff into this SVG element, and this is actually the SVG that I hand coded for that diagram for you about DOM elements.  So this is just everything in that diagram all at one level.  And so here it's not too hard to understand, but you can see that in a much bigger project, much bigger than that little diagram, debugging something like this in your console is going to be, you know, inspecting it to examine how things are layered, would be a challenge.  One thing with SVG is that order matters a lot, so you do have to inspect the console a lot, there's no Z index in SVG, so you have to put things into the SVG element in the order that you want them layered.
      So here's an example where we're actually using groups to organize things.  And, in fact, each row of that diagram binding one data to a DOM element is a group here.  And what's nice about this is that the groups actually give us hooks for interactions pretty easily.  And lots of different ways.  Here I actually did a native SVG animation, but you can also apply class to each group -- wow.  And do it with CSS animations, you could do it in the JavaScript.  SVG is another one of those areas where, like, a lot of things there are probably 100 ways to accomplish the single task.
      And now here's the third reason to use groups.  There's actually performance implications if you don't.  This is a little bit of a silly example so all I'm doing is I plotted 5,000 random data points in a scatter plot, and then I'm shifting them all by a certain number of pixels and this gift of the example where I did this.  If you shift after you've plotted all those circles inside the group element and you're shifting them by applying a transform to the group, it's basically negligible performance, you know, it happens in zero milliseconds, one millisecond.  If you do it the dumb way by plotting all the circles, selecting a transform to all of them, that actually takes a little bit of time.  Now, it's still not noticeable to the user because it's, like, 12 milliseconds.  But the point here is the more complex you're getting with all these things, all that stuff is going to add up.
      And so that is leading me straight into this discussion of profiling performance and data visualization.
      So just like any experience of a website or a Web application, when you're doing something with interactive data VIZ, obviously you want it to be snappy and Chris.  And smooth, you want your users to have a good experience and not have any noticeable lag or desynchronization or stuttering.  But sometimes that's just not what happens, especially in my experience, like, in the first iteration of a new project.  So I'm going to talk about how in the past I've figured out what the problem is that's causing some performance problems from the point of the user and how to solve them.
      So these are kind of from the most obvious to maybe the least obvious.  There are three things that I do a lot to profile the performance of a data visualization.  And that's just putting timers in my code, using the frame rate meter in Chromes and reporting a more detailed timeline profile.  Also I use Chrome's developer tools for that, but I do believe the frame rate meter is unique to Chrome.
      So timers are pretty obscene beginning technique for profiling performance.  But that's not to say that it's not useful to talk about them a little bit I think.  I almost always now wrap a timer around the main render method in any visualization that I'm working on because the render method, which is where you're actually manipulating the DOM in respect to the data, it tends to be the most expensive part, and especially, especially if you are starting by working with maybe a prototype data set, a data set that actually not the real data set, and then you're going to scale it later, you should have a timer around that data method so then you can go to scale.  I've been benefit by that before.
      I also prefer to use the console dot time and time methods.  I don't know if everybody knows about these.  They're very useful.  You don't have to the to do the calculation of the elapsed time.  Not every browser has them.
      But the only other thing to say about timers is you have to know where to put them, if you don't know where your performance problem is, then this isn't going to help you.
      So one of the places just to get an idea where you might have performance problems is spying on the frame rate of your visualization or of any Web application.  This is something that applies a little bit more broadly.  So I'm not going to walk you through the steps here, but this might be a little bit more useful, which is I didn't gift it for you.  But an important thing to note is you actually have to have the developer tools open for the frame rate meter to stay there.  It will be in the upper right of the viewpoint.  So I often pop the developer tools out and minimize them if I actually don't need to inspect stuff and then leave it open.  I leave it a lot while I'm developing.  It's a good thing to keep an eye on, and it can be fun to surf the Web with the frame rate meter on ands what other people's websites are doing.
      So this is in example of, you know, having the frame rate meter open to profile a certain interaction.  So in this case, again, a little bit silly.  I put this button in there to invert the Y scale of this scatter plot, and there's actually a little gradually increasing delay on the interaction -- or which data point moves to make the animation.
      What I want to point out here is, like, this is the frames per second that you're seeing in this interaction.  And this 30 to 60 here is the range.  And so that's showing us that throughout this, none of these dips on the timeline are going below 30 frames per second.
      And then here's an example of the same interaction but this time I plotted 5,000 data points in the scatter plot, and that has a considerable negative impact on the performance as you can see.  The frame rate has dropped into the 20s, the range we have now is five to 60 instead of 30 to 60.  And another thing that I can just point out here is that performance and data visualization is often a really simple numbers game.  If you're plotting more things, if you have more elements in the DOM, things are going to be slower.
      So this is straight from Chrome's developer tools.  It's just showing you what's in that frame meter display.  So there's the current frame rate, the ranges, I said before that's the minimum to the maximum.  And there's this cute little histogram that's hard to read, but it's useful, especially if you leave the frame rate meter open for a long time, you can see over time where its weighted.  And then the timeline as you're doing things.
      So this is my biggest caveat about using Chrome's frame rate meter.  It is that reported number is a main running average.  So it's not the -- quite the right tool formally precise identification of problems.  Basically it's good for ball parking.  And getting a general idea of how, you know, if you leave it open for a long time while you're working, you get a really good idea of how well your website is performing sort of between refreshes.  Or you can set up tests and get a general idea of whether this interaction is doing well or not.  But it's not going to pinpoint anything for you.  It's just not good for that surgical precision as you might call it.  So when I first started using the frame rate meter, it was really good for me.  It gave me this quantitative performance that you already have sort of a intuitive grasp that can be helpful for really finding problems.  But I didn't know what the numbers meant, so here's my guide for you on what the numbers really kind of mean.  And basically I would say anything above 40 is just pretty good.  Your users probably aren't notifying any lag or stuttering because any of those things are just rare or subtle.  30 to 40 is a really discerning user might be noticing something, like, a little bit of lag or a little bit snappier or smoother.  And under 30 is where people are really going to start to notice.  No one's going to say to you the frame rate of this is slow unless they have a background in animation or something.  But they might notice.  They'll describe it as sluggish or lagy.  Not smooth.
      All right.  So now moving on to profiling with the timeline tool.
      So this is the one where timers and the frame rate tool are not really good for finding the code that's responsible for your performance problem.  So that's where you really need this tool, the timeline.
      So in this scatter plot, what we've been looking at, this is the function I've been using to generate data, and I'm just going to show you another version of it for comparison.  So here's the original version.  Now, this one, the generate data slow function is a -- this is going to be our white whale.  I put this example in here so we can find a bottleneck using the timeline tool.  And this is inspired by real mistakes that I've made.  One of the difficulties with dealing with a lot of time series data is that you -- different parts of your code might expect dates and times to be in different formats, like, strings, JavaScript date objects, integers, and especially if your code base is complex, these different modules have different expectations, you end up parsing and reparsing date times in many ways, and daytime parsing is usually pretty expensive because it's pretty complex.  And so that can really end up causing problems.
      So this particular example obviously is really silly because this is not a complex code base at all.  And the problem here just to really point it out is I'm creating a new date and then immediately formatting it out to a iso format string, and then I'm pushing the data into the array, I'm parsing again with date dot parse, which produces an integer, and then I'm parsing again with moment, which is a JavaScript library for dealing with day, times, and getting the day of the week out.  And this is actually a really slow way to get the day of the week out by formatting it into a day of the week with moment.
      So, again, here's just a little demonstration of the workflow that I use to set up a timeline profile in Chrome's developer tools.  Not going to walk you through it step by step.  But I'll point out that -- so I've set it up so you get it all in a frame view, which is in these vertical bars, and there's color coding on those vertical bars.  Blue for loading, purple for rendering, green for painting, and then yellow for JavaScript.  So basically when I do this, I always zoom in on the tall, yellow bars to find potential JavaScript bottlenecks.
      And when you're looking for bottlenecks in this timeline in the frame chart view, which is the view I prefer, and we'll look at one in detail here in a minute.  You'll want to remember that width represents time, and that's the dimension you're really interested in.  The vertical nature of that frame chart view represents your call stack, but that doesn't really matter at all how long that is if you have a huge call stack as long as it's not taking up very much space in terms of width.  So really you don't want to get too concerned with that.  Basically I look for things that don't make sense in terms of width.  And another thing to note here, and this is actually something that took me quite a while to track down when I was first doing this, and then I've linked this stack overflow of answer here.  These slides are online.  Is that sometimes you'll see in these horizontals blocks is that that confused but he at first because I thought it was one function that's getting called more than once, about it's not significant when that splitting up happens.  It has to do how Chrome or another tool is, like, statistically stamping your kale stack to produce these charts, and sometimes things get split up, and it's not significant.
      So here's one example of one of these timeline profiles, and this is for the original data generate function that's not slow.  And this is probably a little small, sorry for that.  But this part here -- I'll try to do both sides.  Is the amount of time that it's taking to generate the data, and it's about less than half of the blue box, which is for drawing the data.  Now, that makes sense.  That's not strange because as I said before, usually the part where you're actually rendering and manipulating the DOM is the most expensive part of any data visualization rendering.  So that makes sense.  That's fine.  Now, here's what happens with the white whale that I put in for us to find.  This generate data slow function.  Now the data generation, again, the black box is taking, like, three to four times longer than the drawing.  So what you would want to do here is look into the call stack into these functions that are being called below inside that generate data slow.  And that can tell you what you see if you're in the Chrome developer tools and you can hover over things there, and it will tell you the name of the function.  Or it will at least tell you what module it's fro.  These are all calls from moment.JS because of some of the silly ways that I did the times and asked it to reparse this date time.
      All right.  So that's the three tools for profiling performance.  And now I'll briefly just talk about a couple of general strategies and tools for getting over some of these performance problems.  Other than, you know, being intelligent about how you deal with your time series data.
      If I was asked just everything that I've learned about making performance data interaction visualizations into a statement, these would be it.  The first one is if you have a choice of implementing your own version of something in JavaScript and going with a browser native verse version, use the browser native version.  And I have a specific example for you here in a second.  And the second thing is try to change the DOM just as little as possible just because that's the most expensive part of this whole process.
      So I've spent a lot of time over the past couple of years working on horizontally scrolling timeline in visual data, and there's two strategies for implementing this kind of thing.  One is to render a really wide SVG that you're only seeing part of at any given time.  And then you're using the browser's native controlling capability.  Or you can render the SVG exactly the size of the portion of the timeline that you want to view it at any given time and attach mouse events and touch events and change what you're actually rendering within that little SVG as the user's interacting with the display.  So that's your navigation.  So at first I thought that this second strategy made more sense because I thought the rendering a really wide SVG strategy was kind of strange and counterintuitive.  But after having performance problems with that original implementation I did a lot of experimentation, and browsers put a lot of into work things like image scrolling performance, societies really not a surprise using the browser's native scrolling abilities there is more performance.
      And here's a little bit of evidence for that, the frame rate was in the 30s, and this is a toy example that's not even as remotely complex as what I first actually working on for my company.  And then here's a browser native version, which has a frame rate that's way up in the 50s.
      And the code in these toy examples it blocks.org, if you don't know about this.  Blocks is a website that's also contained by Mike, the primary author of D3.  And it's built on top of GitHub gist, so you just put your GitHub user name into the URL, and it renders things.  So if you have an index HTML, it will render it.  So it's a great place, and basically where the D3 community puts all of their code examples, instead Codepen.  So it's a great place to look for D3, and the URL later on my blocks page if you're interested in seeing these examples.
      So lastly any final tip is try to not touch the DOM as much as you can.  And, again, this is something that's not particularly innovative, obviously Facebook's react is a entire front-end UI framework that's built around minimizing DOM manipulation.  But just because it's common just doesn't mean it's always easy to remember.  So I just think about it a lot when I'm working, ask myself how much am I changing the DOM and can I avoid it?  So, for example, this huge scatter plot there's probably a different way by aggregating it or smoothing and there will probably end in fewer elements modified.
      And if you're coding in interaction that's stability constantly removing nodes from the DOM and adding new ones, which is basically exactly what you're doing when you're doing a timeline that scrolls, is there a way that you can recycle the nodes that you're about to remove so that you can reuse them and basically that means just changing the data that's bound to them so that you're not removing them and then adding new runs.  You're just recycling the ones you already have.
      And then my last tip is for deal with large data sets.  There's a couple great libraries for this, cross over and poor over, these are both over source tools.  Cross filter is your first choice for filtering helper with D3, it's written by some of the original authors of D3, and it provides a real wealth of functionality for numerical queering.
      And poor over is a little bit different in the original use case for it was client fast search.  So basically if that is your exact case, it might be a tool to look for first.  It's basically sort of tag filters in many combinations kind of use case.  So that would be worth checking out.
      So just to give you a very brief overview, my tips for powerful, data visualization are to learn SVG as much as you can.  Profile as you work.  And strategize, let the browser do as much work as possible, touch the DOM as little as possible, and use the helper libraries if your data is really big.  Thanks.
      [clapping] 
