      >> Oh, nice.
      >> That is pretty awesome.  So are there cats in Minecraft?
      >> Actually there's, like, a special mod to make cats, but they are not a native specious to Minecraft.  There's cows, pigs, horses, sheeps, donkeys, mules, wolves, ocelots -- well, ocelots are cats --
      >> There you go.
      >> I'm trying to think of whatever else.  And then there's zombies and zombie pigs and skeletons and the creepers who blow up and everything.  Yeah, I actually had to keep it from turning into night while we were waiting for the presentation to start otherwise we would have had all sorts of spiders all over the place because they come out at night.
      >> So you're saying zombie cats are next?
      >> I cannot say one way or another.
      >> All right.
      >> But Microsoft's bringing out a new version of Minecraft at the end of the month.  So we'll see what they put in it.
      >> Awesome.  Thanks so much.
      >> Thank you.
      >> Great job.
      [clapping]
      >> Obviously kids would love that topic.  Exploding pigs.  I thought it was hilarious.  So that seems like a really fun thing to teach the kids.
      So we're getting the next speaker set up, Adam Baldwin, he's from &yet.  So Adam is here to talk to us about security.  And the art of identifying vulnerabilities.
      >> You said security, I said vulnerabilities.  I thought we were talking about feelings.
      >> Take it away.
      "The Art of Identifying Vulnerabilities."
      By: Adam Baldwin.
      >> All right.  Get excited.  It's almost lunchtime.  So as stated I'm Adam Baldwin that's where you can find me on the Internet.  I'm from a wonderful place called &yet where I run the security team and started and coordinate the node security project.  And I'm here to today to talk about the art of identifying vulnerabilities.  And so back when I stepped out of the security community in 2009, and I stepped into the world of DEVs, I did my first conference talk at DjangoCon 2009.  And, you know, I -- I was an outsider coming into the developer community, and I wanted to take, you know, the knowledge I had in the security community and to the source where, you know, bugs were formed; right?  Developers.  And I got the question -- I immediately got the question how do you do what you do?  How can I do what it is that you do as if there was some mysterious thing that we did that was different and make my code better.  And I was very ill prepared to answer that question.  I thought I would be able to explain things better.
      And it's taken me since then until now to actually put together this talk to figure out what those sort of -- what those things might be and actually distill it down into a what could be a repeatable process.  And that's what I'm going to share today.  Is my thoughts and perspective on this, and it's probably going to jump around a bit.  To me it fields like the matrix when I look at a application and I look into the nooks and crannies.  So I'm going to do my best to put that in a linear word for you.
      We're going to start with -- so what is a vulnerability?  What is vulnerability?  And what are we looking for?  Is it a bug?  Simply a bug?  And I think that's true.  Is it a weakness?  That's my favorite security failed picture of all time.  Yeah.  Vulnerabilities just a weakness in a system.  It's the weakest link in a chain.  So many a vulnerability is a promise that can be broken.  This is a patent picture of a lock.  Locks, you know, give a promise of some type of security, but you can pick them or a padlock you can shim them with a little piece of aluminum from a soda can.
      But, you know, we're looking for things that can break the promise of confidentiality, integrity and availability.  Things that create weakness but most importantly we're looking for bugs that we can fix.  You know, that's the saving grace here is that it's just bugs.  We can fix them.  There's nothing to really worry about.
      So here we go.  To find vulnerabilities, you need systems knowledge.  You need security knowledge, and you need my favorite part of all, curiosity.
      So systems.  Vulnerabilities grow in the cracks between nuances and assumptions to find vulnerabilities, you must understand the nuances of the systems that you create and consume.  In JavaScript, you know, what the health care is the event loop anyway?  That's a great, you know -- that's a complex, complex thing that we have to deal with.  This is a great talk by a team member of mine, Phillip Roberts.  That's something that if blocked; right?  We have vulnerability hits or we have an attack against availability.
      So my other some other great resource, the slides will be available.  Some other places to find and understand the pitfalls of JavaScript nuances things like the equality table; right?  It's super confusing and also the other one, you don't know JS is a great book serious.  You have an interesting advantage as developers when it comes to systems compared to as an outside security individual.  And you -- you have -- you're closer to that code.  You have a deeper understanding of that code and how those things are put together.  We on the other hand from the outside when we have to audit code, we have to figure that out very quickly.
      And anyway I'm bailing.  So hopefully you saw Helen's talk yet about prototypal inheritance, another new thing about JavaScript, and the area is growing when we get to EOS6.  And here's my new nuance of JavaScript.  It seems really simple right.  The double equals.  It's just something we need to take granted.  We use it probably every day.  Double equals and triple equals.  Does anybody know how that actually works and could tell me?  It's on this slide.  You can't read it.  Basically 262, like, there's this tons and tons of, like, conditions that it goes through as it compares a string to compare equality.  And we can abuse that as attackers to guess strings that we can't see because of timing difference.  How long, how far down in this chain of events do we get byte by byte, and you should use constant time functions in crypt details.  That's my favorite nuance.  It's so simple, it's so often ignored.
      And system stuff.  Vulnerabilities are present between one system and another.  So as you're going to find vulnerabilities where data changes hands between one function and another or a client to a database.  But it's not just about the code that we write and the data flowing through that code.  It's about other systems that we use and consume.  Who here uses NPM on a very daily basis; right?  Probably a good majority of the room.  I love NPM.  It's a system that provides input into the applications that we write; right?  We add dependencies from our project to other people.  We're taking untrusted or trusted client into our projects.
      I really like the data visualizations from yesterday of how the dependency graphs from and that shows the power of one individual, and one individual's account and how that affects your dependency tree.  This is a -- just a simple graph showing that the red dots -- I have it blurred out because I don't want to say basically who it is.  And the red do the shows their packages and the packages that depend on those packages and so on and so fourth and the more popular you get, the more impact.  And who here has changed their NPM password in the last 90 days; right?  It goes into a config file, we don't change it.  But you're relying on the security of others in that network to provide security in that application as well.  You're taking that input.  So taking consideration we'll take those credentials as well.
      Define vulnerabilities, they multiply the complexity from the presence of complexity, who -- if you're running node production, you probably got to a update yesterday because of some open SSL vulnerabilities, the open SSL is complex, it was just a simple bug, but it allowed basically the two in the middle and impersonate a certain -- that's 300,000 lines of code.  It's complex.  We trivialize and say just make a request for the seven.  There's an amazing amount of complexity that happens to the stack from applications down to the network and back again.
      And the thing there is I could be contrary in the example I'm going to show you at the end goes against that, and we'll show a module that is really very simple yet has a vulnerability in it as well.  So don't let that be deceiving.  Complexity is where they thrive, but something as simple as a module can have a vulnerability as well.
      And I just love this tweet.  So sometimes -- I marvel that every computer is on fire all the time.
      So security.  Let's -- we've talked about systems, we talked about the fact that we need to understand the nuances of the things that we create and consume.  So let's put on our security hats.  This is -- I'm not a hacker or a white hat hacker, I'm a pink hat hacker.
      So where to start; right?  So if we're talking about security, where do we want to start?  And what I thought would be of interest is this phrase is always thrown out as you go find vulnerabilities and applications you need to think like an attacker to defend your application.  What the hell does that actually mean?  So I asked my team to give me a couple of quotes.  You know, John says I locate the intuitive trust and the relationships between developers, software, and users, and manipulate them.  The trust that happens without conscious decision, like, a person sitting in a chain, assuming someone hasn't removed one of the legs since they last sat in it.  How many of you checked how many legs are on your chair before you sat on it?  We make the assumption and sometimes those legs can be pulled out from under us.
      And John says how he can redirect those toward himself without making either party aware.
      Matt on my team says an attacker to him means we try to push the boundaries of useful things to see how we could get them to do something that it wases designed for.
      A simple example would be a screwdriver.  It's useful for its intended purposes, but nefarious purposes as well.
      To me when I'm given a code or application to audit, I think about what promise does it make?
      And if you have a module and the thing is that it can be used in many different ways and many different purposes in many ways you didn't intend.  You vulnerability exist in a module when it makes a promise and doesn't satisfy that promise.  As exampled, the mark library can sanitize take mark down and sanitize as a browser so you don't get across scripting, injection issues.  However, that can be -- in one version you can put BB script in there, and it would be certain browsers it would bypass that.  So it makes a promise, and yet that promise can be vulnerability.  So that's a good example there.
      And also when I look at a server perspective.  How does it make money?  Those are the important things to protect, vulnerability of, you know, protecting that core thing of how it makes money.  And ability often -- or availability often gets forgotten.  Availability, however, this is a security concern, and it's the most felt by your users.  If something is down, it's going to be felt by your users.  If something is, you know, snipped on the wire, it's not as impacting.  It may be just as severe, but it's not going to be as felt.
      So now we've talked about systems stuff, security stuff, but, you know, how do we gain knowledge about how sort of attacking these nuances and assumption the standard one if you haven't heard of the OS top 10, that's I great place to start.  It gives you ten areas into much you can focus your efforts in learning about vulnerabilities.  And abusing applications.  You know, from injection to, you know, miss configurations.  All those type of things.  Please, if you haven't read this, just spend a little bit time there.
      Also this one I really love.  If you want to know how to get better at hunting security bugs, read security bug reports.  And the thing is we don't have a lot of vulnerabilities in the ecosystem.  We've got some out of the node security project, you don't have a lot of detail there.  But that's where you're going to get -- that's where -- like learning from basically others, learning from other platforms -- this thing doesn't click.
      Learning from other -- this is a great resource from other languages that have basically you want to learn from their mistakes.  If we don't -- we're resting on the shoulder of giants, and they've solved these problems and we're just another language, and we should rise up and be better and make the same mistakes as other platforms.  There's no need to reinvent the wheel, the majority of the time.
      Now to get to my favorite section of all is curiosity.  Because you can all of the knowledge about systems and all of the knowledge about how to abuse those systems.  But if you don't actually get off of your rear end and actually look, you don't find anything; right?  If we don't actually take the time, take part of the our day, our sprint, to look for these things in our code and systems, we're not going to find anything.
      And my favorite way to put it in motion, to -- is to act ridiculous.  Calculated reckless abandon, that's my daughter, she's wonderful.  But it's stimulus response.  Do things to your application that you normally wouldn't.  Don't -- basically shed all prior knowledge.  Act like a child.  They want to get into something, they're going to get into it.  They're going to bypass whatever child lock you put on there or they're going to manipulate you socially.
      [Laughter]
       -- to give them whatever you want.  And this, again, you could just throw in -- under score, under score Protestant owe everywhere.  How many have tried to put that into every input field that they found in their JavaScript application?  Things break.  Lots of things break.
      And then, you know, this is my son on a rocking horse on his skateboard.  Just because.
      How can it be used in other ways?  How can -- you know, how is a user going to use your application that, like, what assumptions are you making and how can it be used?
      So the other -- another tip is avoid -- or ask questions and avoid statements.  What I hear often is a user would never.  That's a big red flag.  It's, like, throwing that penalty flag.  If you ever hear yourself saying that or a coworker saying that, nope.  We need to have a test for that.  That's just -- I don't know.  Red flag.
      And in the end, you know, I say more about what you don't know than what you know.  You have -- like I said you as developers are close to your application, so it's easy to be blinded by the suggests has been you made by writing it.  So, again, bouncing it off that peer, having a peer review is good.  But trying to shed that knowledge and doing so by just acting ridiculous, throwing strange inputs, they call it fuzzy, it has a term, throw stuff at your application.
      So that was the high level, like, what I'm thinking about when I think about systems and security and how I put that into motion in a very, like, light sense.  And now we're going to do just a little, like, demo.  This is her hacking.
      Okay.  And this is the process that I go through.  This is, like, the TLDR, too long was boring.  Didn't listen.
      Basically I look at the code, I understand the threat model.  What is it used for?  What does it do?  What's it intended to do?  Identify the inputs, you know, the thing that are -- you know, taking data into the application.  Identify the syncs.  The syncs are basically that those functions that if something -- if certain behavior ends up in that function like E valor expression or -- a sync is one of those.  If it ends up there, it's bad.  You've traced those things, you've tested and validate and repeat.  And, yes, it is very boring, and it doesn't look like anything in the movies.  It's just typing.
      So let's see if I can learn how to use this and show you what I'm going to demo.  That didn't she opinion.
      Okay.  So I have -- that's actually somewhat legible.  So what we're going to look at is a module called MS, of course the network is not going to work.
      We're going to look at a module that does millisecond time conversion.  Who would expect a vulnerability in a module like this; right?  Would anyone -- a few people.  Okay.  Because you know we're going to find one.  So I didn't.  And we audit modules and we, like, just have to do it.  I have to go through and look at this.  This is part of my job.  So it's, like, I started looking at this module and it does time conversion.  It takes in some strings and some arbitrary values and, you know, just dumps out milliseconds.  So that's great.  We know what it does.  Now let's go look, you know, if you go look at, like, the actual module, and you go through it, it has one module exports and takes in some values and options and it does some things.  So if it's a string, it passes it to parse.  So we're going to follow it down into parse, and parse compares it to a regular expression, so that's my first, like -- it goes into a regular expression.  In a regular expression if you, again, once you gain that system knowledge and systems just, you know at that regular expressions are actually a nice sync.
      So if we didn't know that, we might say a regular expression, what a regular expression, do they have any attacks?  We put regular expression attacks into this wonderful computer machine thing.  We get, you know, we find -- we can gain knowledge on the fact that there is a thing called regular expression service.  So given the right input, the right regular expression and the right input, we actually -- we actually can end up with a denial service condition.  We can block that wonderful event loop that we want to -- that we want to keep, you know, spinning our call backs.
      So we go back and we say okay.  We have a regular expression.  How do we know if it's vulnerable?  We can read that paper.  There's a really cool module from of course substack.  You can run it through this module that will tell you if that regular expression is vulnerable to regular expression service.  It's really cool.  We're not going to do that.  But another way is just to kind of look at what that regular expression looks like in this debuggex.com, and this is not going to show up well.  But just plug it in there, and it shows you what it's doing, and it shows you a decimal dot decimal, and what it looks like in the end.
      However, as you go along, it matches, it matches, it matches, but you can see that it wants -- we can still put in the characters at the end.  So we can just putting decimals and the input can be as long as we want, and we can put, like, minute, and then it matches and we just put some other random character, and it fails.  That's fine.  It's not the really blocking anything.  However, if we take -- exit this.
      This is a little test thing that just basically generates a really long string, you know, whatever I wanted and then it adds, like, the minute A at the end; right?  So I'm going to say whatever I pass it in a big, long string and then throw it at the end of it and pass it to MS to see if it parses it.  So we run, like, you know, like I did in the example, 20 -- it goes really fast.  But as soon as we start adding on, like, if we go to 10,it starts slowing down a little bit, and we double it -- and these are still values that are very, very small compared to the Max size for most HP requests.  So if you start taking this under the IP server, that starts increasing -- that time that it's blocking keeps increasing, and different regular expressions you run into will, in fact, have different amplification amounts.  And there's different categories of, like, cross scripting or forgery or denial service or what have you.  There's tools that have been created to help test these things.  They're not always developer friendly, but they do exist if you go looking for them.  So it just --ton amplifies quite a bit.
      He blocked the attack and said okay.  It can be 1,000 characters long or something, and it's, like, nullified.  So it's really easy to mitigate in a lot of issues.  Or a lot of situations.
      So that was basically demo -- very simple, like, walk through of my process, and I've got some of my -- so this, again, we understand the code, it doesn't use any built-ins, we understood it, we follow the source, after we identify the inputs, there.  She's going to hate me some day.
      Identified the syncs where it went and, you know, we -- this is something I didn't show.  But something that we use often too is ES graph is a great utility to do call flows.  To see how data flows between inside of an application.  Just an example there.  It's another tool to use.  We tested and validated, we looked at how it worked, how we got that amplification.  That was really for the demo.  Once you go from manual auditing, you find how you can find it from a manual perspective, you can take it into an automated area.
      So whenever we identify one of these syncs that may be bad, we made rules internally -- so I've got this rule called EV, and it just runs and tells me that, hey, there was a regular expression.  So it found the regular expression by parsing the EST, there's some false positives, but I can take it up on every module on the system and find those and flag those, and it's easy for you to do as well.  Those are up on my GitHub.com/evilpacket, there's some ES rules up there for this particular one.  And also you can do -- yeah, I'm out of time.  So if you want to know other automated stuff that I've been working on, come talk to me afterwards.  Like, I'm really excited to use docker that has malicious commonly you'll see to install crypts.  And it's really fun.  Final message is be okay with boring, monotonous, and unfruitful testing.  Just like a cat trying to get into any sized box.  Be persistent.  You will find ventures.  My last note do not do it all at once.  Pick one of the categories, share it amongst your team, amongst the community, you know, write some good blog posts about these things.  We need more about it in the node community.  That's it.  Thank you.
      [clapping] 
