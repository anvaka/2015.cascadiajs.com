      Hello, CascadiaFest! The livestream captions can be followed on your handheld devices at 2015.cascadiajs.com/captions.
      [Captions provided by @chaselfrazier @whitecoatcapxg. Thanks to our sponsor @mobify!]
      >> Welcome back.  How was lunch?  Did you all have, like, three pieces of cake each?  Four pieces over here.
      >> Going once.  No more.
      >> You can't talk yet.  What are you doing?  No, I'm just kidding.  Welcome back.  I realize that a few of you maybe comatose from the amazing lunch that was provided to us, but I'm really excited to introduce Shay, Shay Howe, he works at a company in Chicago, so he's traveled a great distance -- originally from Ohio; correct?  Is it Lima or Lima? and Shay's going to talk to us about maintaining style.  So when he told me I was, like, okay.  Do you mean CSS selectors or style tiles or, like, visual styles and what he told me is two of those things had a baby, that would be his talk.
      >> It's true.
      >> I need the energy up, like, a little bit at least.  I'm tired too.  I ate that lunch.  I ate that cake.  Don't worry.  We're all here together.  Yeah, so if you guys could do me a big favor and welcome Shay to the stage.
      [cheering and applause]
      >> Thank you so as Julie mentioned I'm Shay, I'm a designer and developer and product person.  I had a startup called belly in Chicago.  I can't see you, but is anyone from Chicago?  We can't chat, we should hang out.
      But today I'm talking about sharing CSS across multiple bases.  And we build websites a ton, it's crazy how many websites we actually build.  And each of the websites serve a different purposes, so we put them on different code bases, but they all share very similar styles and very similar CSS, and this gets to be troublesome as we did you happen indicate our code.  I think the clicker is dying on me.  Now it's going too far.
      So we have a member facing as well as a merchant facing website.  And as I was saying these are on each different code bases, and work our way around this.  However, we are duplicating our style as we do this, which is not good.  We have an entire slew of merchant actuals, a knowledge center, different analytics tool for them, very different style, yet entirely separate code bases, and this doesn't stop.  Multiple blogs, internal tools you name it.  And for the longest time our styles were best and we knew we could do better.
      Now, everything is built on top of a oriented architecture, so if you're not familiar with the service oriented architecture, it's a design pattern where software provides a distinct functionality to services and other applications.  And that's a mouthful so let me break it down.
      We start with the databases.  And the databases store all the content, and these are the front-end applications, the user interfaces.  And sitting between the two are our services.  Now, each service, folks, on one core distinct functionality, and those will then go out and speak to multiple databases -- come on.  All right.  Giving up the clicker.
      Sorry those services go out and speak to multiple databases or a given database and populate the content.  They read and write the database.  And they take all that content and drop it into the actual applications for us.  Now, this is incredibly modular and it scales well.  The great thing here is as any given service reads and writes into these databases, that content is then updated across all the applications.  We don't have to worry about one application serving up a different application than another.  And that's exactly what we want to do with design.  And we couldn't figure out where design exactly fit into this picture.
      Now, our aim in the idea was that we would have modular predictable and maintainable code; right?  We were past the idea of building websites in terms of pages.  We were afloat new frontier of actually building out a system and defining all of our styles across a handful of applications and sharing those common styles.
      Specifically we're talking about CSS, we used Sass, we want to be able share the actual source files tied to it.  We want to share our variables, our mixins, maps, you name it.  As far as JavaScript goes, we use a handful of processors, but CoffeeScript.  And we want to make sure that our modulars from CoffeeScript are being pulled on.  And this goes across any fonts or assets being served up across our applications.  We want to service to predominantly focus on design.
      So we wrote our own, we dubbed it roll decks, it's a toolkit, not a framework.  It doesn't solve for every given problem.  That's okay.  It grows, it changes over time.  It's a living organism, and you guys can take a look at it, but honestly I wouldn't recommend doing that.  I would recommend looking at it, forking it.  I think our styles are unique to us, and your styles are unique as well.
      And I give you a disclaimer.  I'm speaking from my experience today, yours may vary and that's totally all right.  Do what works best for you.  Our toolkit came together kind of like differently than that know what most people auto would say go do.
      We wrote our toolkit in variable with that and the application of a real project.  It might be somewhat taboo, but we didn't start with a style guide.  I've built style guides and try to drop them into an application, and I found that they're rarely used as intended.  So we built out our toolkit and then our style guide based on a real project.
      And with a by the like this, say we have two applications, we have a home page and a style guide.  Our toolkit sits in between these two and serves up styles to each of them.  But how this all came together was that all of our styles and stuff were written inside that home page.  And as we started to shore up the common components and figure out where they're being used, we took them and dropped them into that toolkit.  We then ported them into the style guide.  Now, the style guide itself is a client of that toolkit, which is an important to thing note.
      Those shared styles live inside that toolkit; right?  And our toolkit right now is packaged up a handful of different ways.  You can pull it as a Ruby gem or different ways in how you're trying to grab those styles.  And here you can see the applications can then pull in the source files, they have access to the CSS and the JavaScript and those shared assets.  Specifically down to those actual source files so we can share our Sass variables, mixins, and utilities.
      And any change we make inside that toolkit is then reflected across all of our applications.  So if we decided to change our color of blue, well, you can see that blue take effect in the applications.  The buttons redesigned across all the applications.
      Now, it took quite a bit of time to actually put this toolkit together.  It is still being put together day in and day out.  We had new components to it, removed some, factored others day in and day out.  And I want to share some ideas that we have and continue to practice around the implementation of how we build around our toolkit.
      We were out to break our CSS into small modules.  The idea was if we could get our styles into small modules that they would be more maintainable.  And as such we follow the single responsibility principles.  That is our styles should be independently created and encapsulated.  Every module or style should focus on one thing, one thing only, and one thing very well following the same logic.
      And if we do this right, this will allow for more modules to create an array of styles for us to open up doors for quite a few things.
      So here's some examples.  Now, this doesn't allow us to essentially reuse any of this code.  We can't create an alert based out of this.  This is a component that's not independently created or encapsulated, which is not good.
      What we want to do, though, is break these styles apart; right?  Take any of those shared styles and abstract them.  Here we create an alert module, that being the border radius and padding.  And we create a second module, the alert error, that being the background color and the text color.  And we can create a slew of different modules to apply to the alert module to apply to a array of different styles.  And each of these follow a principle; right?  They're completely encapsulated.  And these smaller large you'll see of style allow us to reuse them.
      And because we have these small modules, we can combine them for others for different results.
      Along like that same lines, though, we don't want to let the HTML restructure our CSS.  We put very thought and intent into how we write our selectors.  The idea is we want to write them for usability, efficient, reduce waste, and repetition of the styles that they entail.
      The idea is we would build these components to be used when and wherever we pleased.  As such we had to make sure that they didn't have any parent dependences; right?  That would allow us to change the elements with semantics, and we didn't want on to have a handful of CSS overrides baked into our styles as well.
      So here you can see we have this featured box.  And when the featured bottom is left alone, it has a gray background, when it's dropped inside an article, at some of a white background.  And this selector that it lives in is not a good idea.  This is troublesome for us.  For one we're overriding some of the default styles, but we're also more importantly tightly coupling those styles to the parent.  And what happens when an article needs to change?  What happens when it needs to become a section or a DIV or what have you?  You're stuck.  That change would then need to be made in the HTML and the CSS; right?  Not always a luxury we'll have some days; right?  We can't change that parent element with the semantics of what we're building.  And this limits the number of elements we can apply these to.  Not ideal.
      Instead we can create a new class.  Here we're not overriding any of the properties.  We've completely removed the dependence of a parent container, and this allows us to adapt to some semantics, we can use these styles wherever we intend.  It's more performance driven, we're thinking more systematically and with the intention for them to be ported and used anywhere we wish.
      But naming is hard; right?  This is arguable the hardest part about what we do.  It's always been hard, I believe it always will be.  And you may follow the block element modifier or the smacks or OCSS approach for naming.  Obviously we use a mix.  But more importantly than that as you name for understanding.  We are the ones who read these class names.  We should be the ones who understand them first and foremost.  Now, ideal these names are functional.  They speak to the function and content of the meaning of the element they're applied to, but we should be able to understand them first and foremost and strive to get a set of patterns when we do this.
      And here I have a handful of classes.  Any guess to what the class PR is?  Anybody want to take a guess?  Poll requests.  Good.  Press release.  Public relations.  So what is UN?  Uncensored.  An uncensored press release we have going on here.  This is a problem, though, because no one knows what that means and you're going to see that and be, like, okay.  I'm just going to go pull up the markup and see what that actually applies to.  And that's troublesome if that happens multiple times a day; right?  Sure we save some time by not punching out characters in the name, but we've caused a ton of increased time and frustration and actually not knowing what that name is down the road.
      Now, these classes are getting to be a bit too deeply nested.  UN, whatever that may be, cannot be moved outside of PR.  And that strength there will cause trouble.  This is not good.  It was priced in unit.  So no idea you would have known that; right?  And you would have had to look that up, and that would have been trouble.  Here we have better names.  And they're not that much longer and work very well.
      Unit doesn't need the unit price, it can get anywhere.  We haven't increased any of the specificity, it's much more modular.
      Here are the class buttons, and these are nothing new.  I deserve no award for deciding these video pit.  But if you look at our alert styles and the names for those, they are right along the same lines; right?  They are very similar to the buttons, they are very predictable, but also functional.  Our labels.  Again, no surprises here either.  These are very obvious and simple examples, it doesn't get much harder than this.  But look at those partners and try to follow them.  Perhaps you have a pattern for what you decide what your for not are or different Z indexes and follow the same patterns.  The best feeling is I can write styles almost guess what the class names are without doing any work in pulling those up.
      Now, I've seen Sass mentioned a few times today, and I want to chat in on this.  And specifically with maps.  Maps allow us to get more done with less code, and that to me is incredible powerful and something I'm always going to try to do.  This is especially true in creating utilities or components.  And one edit inside of a Sass map can create an entire utility or component for us.  So, for example, we always define our variables outside that of a map so that we can use those variables elsewhere as intended.  And then most commonly we drop them into a map too.  And here you can see we have an each loop that iterates through that map and will generate text-based utility classes around them.
      And should we want to add another class, all we have to do is add another line to that map.  It's pretty simple.  We don't have to do the work of writing them out longhand.
      Now, maps are more powerful than that, though.  Here you see a map that has nested list within, and the loop will go through each nested list, and compiled out, this will generate a handful of different alert styles for us.  And the maps here set this up perfectly so that we can just add one more line or change a line in that map and get an entirely different component out of it.  This allows us to scale incredible well, but it also allows us to stay consistent.  Now, if you're using Sass and not maps, I highly recommended you take a look at these.  Because this will get you further than you expect.  And we have mixins too.  And the mixins are the perfect way to share the common group of styles.  I say group of styles very purposefully there.
      Only use a mixin if you're sharing multiple declarations.  If you're using a single declaration, that isn't helpful.  I would just recommended writing out that value pair as intended.  If the value is somewhat unique, I would recommend creating a variable for that instead of a mixin.  Mixins should follow that single responsibility.  A mixin should be independently created and capsulated, their output should do one thing and one thing only and one thing well.
      And the ideal mixin, this is a common group of tiles stiles we found ourself repeating.  Here you can see in terms of a logo; right?  And compiled out, we take those styles from that mixin, we find them alongside the other styles that we're using inside that selector.  This is the perfect opportunity for that.
      Now, mixins also allow us to pass in arguments to them so that they can create dynamic sets of styles for us.  So here you see a box outline module of which you can pass an argument for a border color.  So in this scenario, given the decimal value, we see the border color along all those other styles pulled into this.  Now, this is a great way to share common groups of styles, yet be dynamic and inherent certain types of styles too.  This makes composition easier for us.  And, again, keeps our styles consistent around what we're doing.
      So when doing this, though.  You have to measure and profile your code.  Set a baseline of KPIs, corporate term, I apologize.  But it is important to do.  For us, we use style stats and Web page test to give us high level optimizations and overviews.  This is quantitative feedback as to how we're writing our styles.  We use CSS and CSS, and for more specific optimizations.  More detailed in recommendations in what we could pro have.  This stuff was more qualitative for us.  I can't recommend doing this enough.  I kind of didn't do this enough early on, and find it biting me in the end; right?  You will uncover so many optimizations by doing this stuff with some level of regularity.
      And here's some numbers for a project.  This is a legit application that we're working on.  Version one is what we're using inside of bootstrap, and everything it took us to override bootstrap to get our styles and themes popped into this.  Version two, though, is that of which we use roll decks.  And you can see huge improvements.  First and foremost was to get our file size down.  We knew that with less code we had less control over, and we were able to cut our size in half by following the most basic principles inside of this.  Along with that we were able to dress the number of rules and selectors for unique values we were using.  This means our code is much more inside of our control.  We know what it's actually doing, and this is good.  Furthermore, a lot of our property counts are dipping down and going down in the right direction.  Now, these are not like our KPIs about any stance, but these will fluctuate as we go, iterate, these will go down, and that's perfectly fine.  And we are not perfect, but looking at these numbers gave us the indication that we were going in the right direction.
      But code is complicated; right?  One of the things I did continual and still continually is I'll write things out longhand.  I'll open up code pen and just start punching away and write styles out in a very long format; right?  And then I start to refactor that back.  You have to have patients and refactor and rename and grow willingly around what you're writing.  Leave comments and documentation as you're going too.  If you're writing anything that you think you won't understand in a month, write down what isn't obvious.  Talk about how, what, and why that code is going to exist.  Goodnights slow down, but I think slowing down is a pretty good thing.  I think going to make you twice about the codes you wrote.  As you explain it you might find some optimizations in there that you previously missed.
      But in all, do the best you can all right?  You have to find your way to benefit for modular predictable, and maintainable code; right?  Make sure you're focusing on shipping and on understanding and controlling your code.  If you can get that under control; right?  And you have a good over arching view of your code, you'll enjoy quite a few things, have a much more easy of development, but this is tough, and that's okay.  Nothing's going to be perfect.  You're not going to nail it the first time around.  Just start where you are, do what you have and do what you can.
      Just like this guy, cut loose and enjoy your work because at the end of the day that's what we're doing.  That is all I have.  Thank you.
      [clapping]
      >> Anyone who wants to remake that gift later, let me know, I'm down.  All right, Shay.  Come on over to the hot corner.
      >> Okay.
      >> I'm deciding.
      >> Okay.  All right.  That's all right.  I'm prepared.
      >> Are you?
      >> No.
      >> All right.  So that was a really great talk.
      >> Thank you.
      >> I'm wondering, like, how you got there.  Can you tell us, like, a little bit about your experience and how you got to the point of, like, really optimizing these things?
      >> So for us for the longest time, we were building applications, and you could always tell which was the one we worked on most recently --
      >> Because that belly?
      >> Yes.  Because it would look the best.
      >> Right.
      >> And then we would always be, like, oh, this looks great, but all the other applications looked like garbage.  So a way to standardize those and get the old applications up to speed without having to continual update them every time we changed the style was something we set out to do.  So it took a while, but we got there.
      >> How long?
      >> I think we're still fighting the battle.  Most predominantly, it's, like, sixish months, but that's nothing we dedicated to, it was, like, free time work on this.
      >> Cool so, like, a 20 percent project.
      >> Yeah.  Absolutely.
      >> And how many people are working on this?  Or work on it or have worked on it?
      >> In general, like, less than six.  Yeah.  So our 20 percent time.  We're in Chicago, so we rented an Airbnb in Kansas City, and that didn't help us, that just meant we could torrent a lot of stuff.
      >> You shouldn't admit that in public.
      >> I'm cool with it.  But three of us went down to Kansas City and wrote the core of it and made a core to build on it.
      >> That sounds like an episode of Silicon Valley.
      >> A little bit.
      >> Do you want to help me read some haikus?
      >> I'm not a good reader.
      >> Now you have to.  
