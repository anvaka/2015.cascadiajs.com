      >> You guys aren't ready for this, are you?  I'm actually really impressed with this microphone.  It goes into the bear head.  If somebody had circus music right now, that would probably make this even better.
      You know, if you have to wait awhile to introduce a speaker, I highly recommend wearing a bear suit.  I applaud the bear suit.  I can't even make eye contact with you.
      You know, you guys were barely paying attention earlier.  Bear with me.  I've got to think of another one.  Because, you know, bears are the number one threat to America; right?  There's a lot of us out there.
      Our next speaker, Rebecca Murphey, I heard her speak at my first JS conf, and I took some great information about JavaScript and so let's hear what she has to say.
      "Deploying Client-Side Apps, 1,000 at a Time."
      By: Rebecca Murphey.
      >> All right.  So A I have my box of tissues, and I apologize it's a necessary accessory for me giving any talk.  I was just dying in there, but it seems like I'm not going to cry.  So thank you, Tara for the antihistamines.  But, you know, we're in the home stretch, we've had lunch, my job is to keep you awake during the rest of the speakers.  If you haven't been to a few conferences, I've been to a few conferences.  You might not know this thing that you've gotten to be a part of for the last few days or even if you've just been here today, it is extraordinary.  This is not normal.  I've made new friends, I've seen audiences who were moved to tears, and I felt really truly a part of a community that is doing great things.  So I just want to say thank you to Tracy, Carter, Marcy, and the entire staff, and all of you for letting me be a part of this.  So high five, Cascadia.
      [clapping]
      I also want to say thank you to Jeff Lembeck who talked two days ago -- was that two days ago?  He talked two days ago about -- he kind of did the grunt work for this talk.  So I want to appreciate that.  If you missed it, he talked about designing tools and how if you aren't careful, you can design monolithic tools that are difficult to work with, reason about, and, you know, change and that wasn't supposed to happen yet.  Go back.  Here we go.  Not that far back.  Cool.
      Wow.  All right.  This is the slide we're supposed to be on right now.  This is my remote that's supposed to be telling the slides where to be.  So I want to talk today how we've been rethinking side apps.  So we have things that in turn is single page applications.  So it's some HTML -- or templates, JavaScript, some CSS, that makes there be a Web experience.  And that may be paired with some server technology.  It may not be paired with some server technology.  In our case, we have an app that is entirely a client side app.  It reaches out to a API, but there's no server behind it.  So that's what I want to talk about, and I also want to make a disclaimer here.  This is not a how to talk.  This is not a talk where you should go home and do what I'm talking about.  For one what I'm talking about isn't done yet.  And for two, this is really a talk more about how we thought about a problem, and how we revisited the tools and technology that we're using in order to solve that problem.  I'm hoping at some point open up the code so everybody can see it, but it's not the code you want to put in your own production world, especially if you're not working at the scale that we're working at Bazaarvoice.
      So Bazaarvoice does a lot of things, but we do ratings, interviews, software, for brands and retailers.  So if you're on a project page on a retailer -- I don't know which one I'm allowed to say their name.  Basically if you're on a project page for a retailer, like Amazon.com, there's a good chance you're seeing bizarre choice.
      I worked for about a year and a half on the third party JavaScript application that gets raves and reviews on our customers websites.  It's a single page app that runs inside of other people's pages, that's OPP, you like it?  It's cooler than 3PJS.  So single page app that runs in other peoples pages.  And the way it works, it's a common code base for all of our customers.  And every customer gets a build for every supported locale for every site that that customer has.  And if you think about customer such as -- I'm just going to say it.  Don't tell.  If you think about customer, like, gap, they actually have several different brands, they own old navy and something in the UK, so they have several different sites even though it's one customer, and those sites have to support several different lock always, and we have to make sure we spell color right, like, with a U, and you Canadians understand that, I still don't get it.
      So for a customer who has -- we have other customers who have, like, ten sites and 130 locales, and if you do the math, you can imagine that we're doing a build of their JavaScript in CSS for every site for every locale, every time they make a substantial configuration change.  And so that can be changing some text or changing the color of a button or whatever.
      So the math of that adds up to we can totally be doing thousand or more builds in a day for our customers.  And we can absolutely be doing a thousand or more builds a day if we need to roll out a bug fix to everyone who has deployed since we last, you know -- who has deployed since we shipped whatever the bug was.
      So the way that this build process, like, this build process has a lot of steps.  If you are putting any JavaScript code in production, you probably have a process that's a lot like this.  Or some has aspects like this.  It doesn't matter what all the steps are.  Eventually I got tired of listing them and said some stuff that I forget.  But there's somewhere administrate ballpark of 15 to 20 distinct steps that we can talk about, like, things that happen in the process of taking a customer's intent to deploy and turning that into an actual deployment of the application.  So currently the way n is we have servers that sit and wait to be told that they need to do a build.  Whether they're doing builds or not, they're sitting there thinking about maybe we want them to do a build soon.  So we're paying for that.  And when they get a build message, they literally run for grunt tasks.  So not like the 15 grunt tasks, like four of them.  This is when your heart just dies when you're reading our build code and you find this in it where it's literally shelling out to execute four grunt tasks populating with some arguments that you passed in somewhere.  It's sad, and this is why I have bourbon on my desk.  And these tasks they perform those 15-plus steps that I just showed you.  And these are really terrible.  It's terrible, like, it's not just an excuse to drink, it's actually terrible.  And it's terrible for a lot of different reasons.  The biggest reason is that on that slide before, if there were four things, there were 15 things, so we're not treating these steps as unique things that have input and produce on output, and there's this bunch of stuff we do and then other bunch of stuff and another bunch of stuff.  And there -- so there are collections smaller of stuff, but they're written in a way that you can't reason about them as smaller steps.  You can't reason about them like I said in terms of their input and output.  It means that it's really difficult when something goes wrong, it's really difficult to figure out what went wrong.  And they're written in such a way that they're deeply entangled with each other, and they all have to run on the same machine because they're all writing from the same file system and reading from the same file system.
      And we have a team of people who feel utterly powerless to -- to do anything with this system except not touch it.  Like, that's kind of the state of the world right now.  So a while back we got a thing, like, what is a build?  What is this thing that we're doing?  Fundamentally any build is a set of steps.  Those steps might be serial, they might be parallel, but ultimately the series of steps is triggered by some initial input.  It produces some final output.  And any reasonably complex system, there's pretty much always a chance for some kind of failure to happen along the way.  Our build has to download some images that are on a server somewhere.  Something, like, this is the Internet.  Things go wrong.  And so there's always the opportunity for something to go wrong and our build has to be prepared for that.
      So a step, what's a step?  A step is a unit of work.  It might be asynchronous, it wouldn't be fun if it wasn't.  It probably requires some input, but not necessarily.  It probably depends on some service, not necessarily, but it might.  Some third-party service.  And ideal it is producing some output.  Otherwise we probably might not be doing it in the first place.
      So you can think of different build process as looking, you know, these are kind of three different things that they could look like.  A really simple one that's successful is a series of steps.  A more complicated one might be multiple steps that can be performed in parallel.  And then the sad face one is when a step has to be retried several times before it actually -- before it completes or maybe it doesn't complete, and we have to abandon the workflow.
      If we think about this, and think about how we could represent these different scenarios in code, it would look something like this.  This is a set of steps to be run in series step one, two, and three, and you're done.  So we can represent it that way.  Each step has a name, which is -- it doesn't matter.  It also has an activity type.  This allows us to have multiple, like, the same kind of activity could run multiple times in different parts of the workflow if we need to.  And it also has information about the kind of input that the step is going to require in order to be successful.
      So you think about representing this notion of doing a set of steps like this, and it's not too hard of a logical leap, I don't have it here, but about how we could, you know, do some nesting so that we could actually achieve parallel steps here as well.  A step in this list could actually be a collection of substeps that had to run.
      And what's a step?  Well, a step might look like this.  It sends an e-mail using the simple e-mail service.  It's just a node module.  It acts as a function, and that function has the a argument and returns a promise.  We're using the library, but what matters is we're returning a promise from this method.
      So that's where we kind of were.  We had figured out, like, this is how we want -- this is how we want to represent these.  We want to break this down into really small steps with clear inputs, clear outputs, promise driven, having these recipes for how the workflow is going to work.  And lots of meetings, lots of whiteboards, lots of markers.  And we had worked through what the interface would be for this.  And understanding that all of this is grunt powered up until now.  Grunt that is really not good at passing data in between things and really no has notion of retries or anything like that.  So we have this vision of where we wanted to be, and we had talked through this elaborate system of SQS with and all the systems we were supposed to be running, and we had a plan, but I was really dreading having to do it.  It seemed like that this that we could represent so neatly in that config object, and these steps that we could represent so easily and it returns a promise.  Actually building this system to orchestrate all of that was going to be hard.
      So around this time I went out to lunch with my friend very Joe who is a Java developer, and he's pretty senior.  He -- these aren't, like, literally the tacos I ate, they're pictures from the Internet, but they're probably literally the tacos I ate.  It's in a trailer park trashy in the background, if you went and need to know what to order.
      So I was talking about the project and the plan and describing the configurability of it all.  And he's, like, dude there's this thing called swift, and I'm like that sounds terrible and he's, like, no, not that swift.  Yeah, my joke slide worked.
      So Amazon simple workflow.  Of course workflow is one word, but they're using two letters to abbreviate it.  So similar workflow, and you heard me say just a minute ago the word orchestrate, I shouldn't have said that yet which it turns out this whole concept is there's a name for it, and you can look it up on Wikipedia, it's called orchestration.  And if you've been in the enterprise and written some Java, you probably already knew this like Joe did.  And it turns this elaborate system that we're running into this simple thing and this -- and this is not a plug, you can do this with node libraries and stuff.  But Amazon has actually, like, wrapped this all up into total magic.  And this is what swift looks like.  So you tell swift, this is a workflow for, like, buying something.  So you tell swift that you want to start a workflow, and you have two things that are running.  You have a desired, which is just such a cool name for a thing.  And that desired is constantly saying, hey, swift, you got any decisions to be made, any decisions, any decisions?  And then once the workflow is started, swift is, like, well, yes, I do have a decision for you to make.  And so swift sends a message, like, it provides a message to the desired saying, like, I got this message.  I have -- we haven't done anything yet.  Tell me what to do.  And the desired comes back and says, well, you haven't done anything yet, so why don't you do step one?  It doesn't say step one.  It just says do this and get back to me.
      So you're also maintaining one or more activity workers that are also saying, hey, swift you got anything for me?  And then when they get something, they need to do, the activity worker goes off and does the work and then says, hey, swift, I'm done, and here's the output for my task.  So if you look the this, you can see the illustration of a simple purchase going through the swift system.  And I'm leaving a lot out.  I'm leaving out all kinds of things but this is the fundamental concept of how simple workflow works.  You have a desired, you have an activity worker, and they are just constantly talking to swift up at the top.
      So Joe, the Java developer, says the only with thing about simple workflow as the can be hard to reason about because things happen out of order.  And I'm, like, dude.  We've got this.  We know.  We're really good at that.
      So out of this came this thing we called Pontiac, we call it Pontiac because the system it's going to be building is Firebird, and we like puns.  So it's a system that lets you describe a workflow much like the configuration that I showed you a few slides ago.  And then it executes that workflow for you using swift.  So it creates the desired that knows how to make decisions about what to do next for you.  You don't have to write the desired, it just creates a desired for you.  You don't have to create the activity worker.  It creates the activity workers for you.  They know what to do.  And then it handles kind of one of the interesting things that has to handle is how the -- you know, because you have N activity workers, file system really isn't your friend anymore, and it makes it so the individual activity outputs can get past to the next activity in a friendly way.
      So it's a system that lets you describe arbitrary workflows, arbitrary builds via configuration.  And then to define the individual steps as those really simple modules that receive input and return a promise.  We try this out using kind of a subset of our build, it's a sunset that we call chopper.  And it's -- it has very simple purposes, which is to receive a build message, look up how many locales do I need to build this for and actually create new messages, one for each locale.  This sounds really simple, it is incredible simple, and thus does it defy logic that the current implementation of this in the old system was, like, 60 lines of code.
      So, yeah, it's an incredibly trivial thing, but we thought it was a pretty good way to look at -- to just kind of take this system for a test-drive.  So if you remember the diagram from a few slides ago with a, you know, bouncing back and forth and back and forth, this is what that diagram would look like for what chopper is.  Pontiac gets a build message from SQS, sends and says, hey, swift.  Please get started on this.  Desired finds that there's something for it to decide, it makes a decision and said you should run the GIT locales step.  The GIT locales says I'm done and bounces back and forth and back and forth and back and forth until finally we're done.  Swift says I've completed this workflow and Pontiac will say we're done.
      So we can describe that workflow a lot like the workflow that I showed you a couple minutes ago.  And this is the chopper workflow.  It has three steps.  A couple of things that are neat about this that weren't in there before.  We've actually moved the concept of retries out into the configuration.  It's out of this -- the step has no knowledge of needing to retry.  This is not a true thing in grunt land; right?  Like, if you need to be retrying something in grunt, it's up to you to write that logic in the step, and it's, like, pretty not cool to write that in a way that doesn't block.  Turns out.
      And so, yeah, we're able to say you should retry this one time if it fails because this is a thing that depends on a external service.  We're able to say that you should consider this failed if you haven't heard -- if it hasn't succeeded within 10 seconds.  And we're able to express all of that at the configuration level and keep our steps really incredibly simple.
      So here's that GIT deployment or GIT locales is what this slide should say.  And if we look at the code for the step is it's not even slightly interesting.  It uses a service to go out and get the information that we need, it's called a deployment document.  Read the locales, and then just resolve a promise with a list of locales.  And its job is done.  It has no idea what's going to happen with that list locales.  And that's the whole thing with all 15 lines.  And then that really cool thing is that a step author doesn't have so think about that is making this work.  They're able to focus on the step itself and what that step itself needs to do.  They don't have to think about retries, they don't have to think about anything.  It's just this very simple, like, go get this resource.  And once you get it, resolve a differed.  And that's it.
      So there's some sad face things about this, I don't know how well you can see the two sad faces, but the first two things is that the size of the output of a step is pretty constrained.  Steps can only output a string and the size of that string is not very large.  So if, say, one of the steps is to do a build of all of our JavaScript, we can't have that build itself be the output of the step.  But we can have the output of the step be a string that is an S3URL that points to where we actually put the resources that we built.  So that's one of the bummers of doing this in a distributed way where your activity workers can be orchids multiple machines.  You can't use the file system anymore, but this is a pretty straight forward thing to get around.  We have to store large binary data somewhere else.
      It's not a bummer even, you just have to change the way you think if you think in grunt land where this whole process is running on a machine.  What that means is that there's actually a possibility where, you know, at midnight we don't need to have these instances on and all waiting for a build message.  We could have a very lightweight process that spun up the instances when a new workflow arrives, a new workflow request arrives.  And there's lots and lots of things you could do.  You could get to where you're using AWSs, LAMDA, which is accordingly to execute the individual activity.  So it's nice, it's a bummer you don't have the file but on the other hand you have a lot more flexibility if you take the file system out of the picture.
      The cool thing is everything else.  Retries and currency are first class, and you don't have to think about that in the step themselves.  And if in one -- you know, workflow definition you want a step to have ten seconds and another workflow definition you want the step to have 20 seconds before its considered failed.  Cool.  Like, that's fine.  So you could do different in things different environments where maybe the QA environment just has slower speeds, and you need to have a little bit more tolerance.  But in the production environment you are a little bit tighter about that.
      The clear contract between the steps and want -- I'm, like, giddy about this.  The clear contract between the steps and the incredible encapsulation of the steps is just huge.  And even if you do grunt right, I think these are things that are really hard to achieve.
      Another thing is that the framework itself abstracts kind of known complexities.  This is definitely -- we had to build is using grunt to understand everything bad about it.  But once we understood that retries were hard that encapsulation was hard, that, you know, writing constantly the file system was hard.  We were able to say all right.  Let's get that out of the hands felt individual step authors so that the step authors can just focus on what the step is.  And that brings me to the last plan.  Like, adding a step is exactly as hard as writing the step and no harder.  So if it's a complicated thing you need to do, yeah, that's going to be complicated.  But if you're just sending an e-mail, that's not even interesting.  And once we've written the sent the e-mail step, we can share that across multiple build process.  We're no longer writing the deployment process for Firebird.  We're writing the steps that can be used across.
      The reality check is none of this is in production yet.  It turns out that rewriting a critical build system that isn't visibly broken is something that products aren't, like, cool go do that.
      We have started piloting it, and since we started working on it, we shifted instead of trying to rewrite a existing build system instead of trying to pilot this with some teams who are not automated at all.  It's not that they're bad, it's that they don't exist.  And trying to pilot it with them and move on and out of that we're able to provide some benefits to the team that this was intended for.
      And the last thing that I would see is that, you know, all tools are easy to abuse.  I kind of talk about grunt as, like, the new jQUERY, it's not really the new jQUERY, but it's a little old now.  But, you know, you can do wonderful things with jQUERY, you can do wonderful with things grunt, but it's really easy to abuse them and another case of, like, choosing the right tool for the job and understanding the problem that you're trying to solve before you lo throw technology at resolving it.
      And the other kind of big lesson is that smart people have probably already solved at least part of your problem.  My -- like I am so relieved that I talked to my coworker, Joe, about this.  Even though I'm, like, he's a Java developer, what does he know about deploying client side applications, I would still be working on this and definitely not talking to you today if I hadn't had that conversation with him.  So, you know, life lessons.
      That's my talk.  I am Rebecca Murphey I also have a podcast that's, like, occasional whistle like it, but you might want to listen to it if you find this sort of stuff interesting.  That's TTL podcast, and you can find me there.  I don't know what I did.  Thank you.
      [clapping] 
